var w=(n,e,o)=>new Promise((l,u)=>{var t=p=>{try{a(o.next(p))}catch(c){u(c)}},i=p=>{try{a(o.throw(p))}catch(c){u(c)}},a=p=>p.done?l(p.value):Promise.resolve(p.value).then(t,i);a((o=o.apply(n,e)).next())});import{N as qe}from"./vendor-niivue-DkxzteUE.js";import{l as ze,t as ae,s as Ge,d as Q,a as xe,b as Ce,c as $,e as fe,f as Pe,E as ie,m as je,o as ce,z as pe,g as I,h as Qe,w as _e,i as He,j as Le,k as D,n as Me,p as Oe,r as Ie,q as Xe,u as Ue,v as $e,x as ue,y as Ke,A as Be,B as he}from"./vendor-tf-DNHNmqEJ.js";import"./vendor-DOCzr95M.js";import"./vendor-math-CA38DMGy.js";(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const u of document.querySelectorAll('link[rel="modulepreload"]'))l(u);new MutationObserver(u=>{for(const t of u)if(t.type==="childList")for(const i of t.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&l(i)}).observe(document,{childList:!0,subtree:!0});function o(u){const t={};return u.integrity&&(t.integrity=u.integrity),u.referrerPolicy&&(t.referrerPolicy=u.referrerPolicy),u.crossOrigin==="use-credentials"?t.credentials="include":u.crossOrigin==="anonymous"?t.credentials="omit":t.credentials="same-origin",t}function l(u){if(u.ep)return;u.ep=!0;const t=o(u);fetch(u.href,t)}})();const Ze={batchSize:1,numOfChan:1,isColorEnable:!0,isAutoColors:!0,bgLabelValue:0,drawBoundingVolume:!1,isGPU:!0,isBrainCropMaskBased:!0,showPhase1Output:!1,isPostProcessEnable:!0,isContoursViewEnable:!1,browserArrayBufferMaxZDim:30,telemetryFlag:!1,chartXaxisStepPercent:10,uiSampleName:"BC_UI_Sample",atlasSelectedColorTable:"Fire"},oe=[{id:1,type:"Segmentation",path:"/models/model5_gw_ae/model.json",modelName:"âš¡ Tissue GWM (light)",colormapPath:"./models/model5_gw_ae/colormap3.json",preModelId:null,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:0,enableTranspose:!0,enableCrop:!0,cropPadding:18,autoThreshold:0,enableQuantileNorm:!1,filterOutWithPreMask:!1,enableSeqConv:!1,textureSize:0,warning:null,inferenceDelay:100,description:"Gray and white matter segmentation model. Operates on full T1 image in a single pass, but uses only 5 filters per layer. Can work on integrated graphics cards but is barely large enough to provide good accuracy. Still more accurate than the subvolume model."},{id:2,type:"Segmentation",path:"/models/model20chan3cls/model.json",modelName:"ðŸ”ª Tissue GWM (High Acc)",colormapPath:"./models/model20chan3cls/colormap.json",preModelId:null,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:0,enableTranspose:!0,enableCrop:!0,cropPadding:0,autoThreshold:.2,enableQuantileNorm:!0,filterOutWithPreMask:!1,enableSeqConv:!1,textureSize:0,warning:"This model may need dedicated graphics card.  For more info please check with Browser Resources <i class='fa fa-cogs'></i>.",inferenceDelay:100,description:"Gray and white matter segmentation model. Operates on full T1 image in a single pass but needs a dedicated graphics card to operate. Provides the best accuracy with hard cropping for better speed"},{id:3,type:"Segmentation",path:"/models/model20chan3cls/model.json",modelName:"ðŸ”ª Tissue GWM (High Acc, Low Mem)",colormapPath:"./models/model20chan3cls/colormap.json",preModelId:null,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:0,enableTranspose:!0,enableCrop:!0,cropPadding:0,autoThreshold:.2,enableQuantileNorm:!0,filterOutWithPreMask:!1,enableSeqConv:!0,textureSize:0,warning:"This model may need dedicated graphics card.  For more info please check with Browser Resources <i class='fa fa-cogs'></i>.",inferenceDelay:100,description:"Gray and white matter segmentation model. Operates on full T1 image in a single pass but needs a dedicated graphics card to operate. Provides high accuracy and fit low memory available but slower"},{id:4,type:"Atlas",path:"/models/model30chan18cls/model.json",modelName:"ðŸª“ Subcortical + GWM (High Mem, Fast)",colormapPath:"./models/model30chan18cls/colormap.json",preModelId:null,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:200,enableTranspose:!0,enableCrop:!0,cropPadding:0,autoThreshold:.2,enableQuantileNorm:!1,filterOutWithPreMask:!1,enableSeqConv:!1,textureSize:0,warning:"This model may need dedicated graphics card.  For more info please check with Browser Resources <i class='fa fa-cogs'></i>.",inferenceDelay:100,description:"Parcellation of the brain into 17 regions: gray and white matter plus subcortical areas. This is a robust model able to handle range of data quality, including varying saturation, and even clinical scans. It may work on infant brains, but your mileage may vary."},{id:5,type:"Atlas",path:"/models/model30chan18cls/model.json",modelName:"ðŸª“ Subcortical + GWM (Low Mem, Slow)",colormapPath:"./models/model30chan18cls/colormap.json",preModelId:null,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:200,enableTranspose:!0,enableCrop:!0,cropPadding:0,autoThreshold:.2,enableQuantileNorm:!1,filterOutWithPreMask:!1,enableSeqConv:!0,textureSize:0,warning:"This model may need dedicated graphics card.  For more info please check with Browser Resources <i class='fa fa-cogs'></i>.",inferenceDelay:100,description:"Parcellation of the brain into 17 regions: gray and white matter plus subcortical areas. This is a robust model able to handle range of data quality, including varying saturation, and even clinical scans. It may work on infant brains, but your mileage may vary."},{id:6,type:"Atlas",path:"/models/model18cls/model.json",modelName:"ðŸª“ Subcortical + GWM (Low Mem, Faster)",colormapPath:"./models/model18cls/colormap.json",preModelId:null,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:200,enableTranspose:!0,enableCrop:!0,cropPadding:0,autoThreshold:.2,enableQuantileNorm:!1,filterOutWithPreMask:!1,enableSeqConv:!0,textureSize:0,warning:"This model may need dedicated graphics card.  For more info please check with Browser Resources <i class='fa fa-cogs'></i>.",inferenceDelay:100,description:"Parcellation of the brain into 17 regions: gray and white matter plus subcortical areas. This is a robust model able to handle range of data quality, including varying saturation, and even clinical scans. It may work on infant brains, but your mileage may vary."},{id:7,type:"Atlas",path:"/models/model30chan18cls/model.json",modelName:"ðŸ”ªðŸª“ Subcortical + GWM (Failsafe, Less Acc)",colormapPath:"./models/model30chan18cls/colormap.json",preModelId:1,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:200,enableTranspose:!0,enableCrop:!0,cropPadding:0,autoThreshold:0,enableQuantileNorm:!1,filterOutWithPreMask:!1,enableSeqConv:!1,textureSize:0,warning:"This model may need dedicated graphics card.  For more info please check with Browser Resources <i class='fa fa-cogs'></i>.",inferenceDelay:100,description:"Parcellation of the brain into 17 regions: gray and white matter plus subcortical areas. This is not a robust model, it may work on low data quality, including varying saturation, and even clinical scans. It may work also on infant brains, but your mileage may vary."},{id:8,type:"Atlas",path:"/models/model30chan50cls/model.json",modelName:"ðŸ”ª Aparc+Aseg 50 (High Mem, Fast)",colormapPath:"./models/model30chan50cls/colormap.json",preModelId:1,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:200,enableTranspose:!0,enableCrop:!0,cropPadding:0,autoThreshold:0,enableQuantileNorm:!0,filterOutWithPreMask:!1,enableSeqConv:!1,textureSize:0,warning:"This model may need dedicated graphics card.  For more info please check with Browser Resources <i class='fa fa-cogs'></i>.",inferenceDelay:100,description:"This is a 50-class model, that segments the brain into the Aparc+Aseg Freesurfer Atlas but one where cortical homologues are merged into a single class."},{id:9,type:"Atlas",path:"/models/model30chan50cls/model.json",modelName:"ðŸ”ª Aparc+Aseg 50 (Low Mem, Slow)",colormapPath:"./models/model30chan50cls/colormap.json",preModelId:1,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:200,enableTranspose:!0,enableCrop:!0,cropPadding:0,autoThreshold:0,enableQuantileNorm:!0,filterOutWithPreMask:!1,enableSeqConv:!0,textureSize:0,warning:"This model may need dedicated graphics card.  For more info please check with Browser Resources <i class='fa fa-cogs'></i>.",inferenceDelay:100,description:"This is a 50-class model, that segments the brain into the Aparc+Aseg Freesurfer Atlas but one where cortical homologues are merged into a single class. The model use sequential convolution for inference to overcome browser memory limitations but leads to longer computation time."},{id:10,type:"Brain_Extraction",path:"/models/model5_gw_ae/model.json",modelName:"âš¡ Extract the Brain (FAST)",preModelId:null,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:0,enableTranspose:!0,enableCrop:!0,cropPadding:18,autoThreshold:0,enableQuantileNorm:!1,filterOutWithPreMask:!1,enableSeqConv:!1,textureSize:0,warning:null,inferenceDelay:100,description:"Extract the brain fast model operates on full T1 image in a single pass, but uses only 5 filters per layer. Can work on integrated graphics cards but is barely large enough to provide good accuracy. Still more accurate than the failsafe version."},{id:11,type:"Brain_Extraction",path:"/models/model11_gw_ae/model.json",modelName:"ðŸ”ª Extract the Brain (High Acc, Slow)",preModelId:null,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:0,enableTranspose:!0,enableCrop:!0,cropPadding:0,autoThreshold:0,enableQuantileNorm:!1,filterOutWithPreMask:!1,enableSeqConv:!0,textureSize:0,warning:"This model may need dedicated graphics card.  For more info please check with Browser Resources <i class='fa fa-cogs'></i>.",inferenceDelay:100,description:"Extract the brain high accuracy model operates on full T1 image in a single pass, but uses only 11 filters per layer. Can work on dedicated graphics cards. Still more accurate than the fast version."},{id:12,type:"Brain_Masking",path:"/models/model5_gw_ae/model.json",modelName:"âš¡ Brain Mask (FAST)",colormapPath:"./models/model5_gw_ae/colormap.json",preModelId:null,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:0,enableTranspose:!0,enableCrop:!0,cropPadding:17,autoThreshold:0,enableQuantileNorm:!1,filterOutWithPreMask:!1,enableSeqConv:!1,textureSize:0,warning:null,inferenceDelay:100,description:"This fast masking model operates on full T1 image in a single pass, but uses only 5 filters per layer. Can work on integrated graphics cards but is barely large enough to provide good accuracy. Still more accurate than failsafe version."},{id:13,type:"Brain_Masking",path:"/models/model11_gw_ae/model.json",modelName:"ðŸ”ª Brain Mask (High Acc, Low Mem)",preModelId:null,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:0,enableTranspose:!0,enableCrop:!0,cropPadding:0,autoThreshold:0,enableQuantileNorm:!0,filterOutWithPreMask:!1,enableSeqConv:!0,textureSize:0,warning:"This model may need dedicated graphics card.  For more info please check with Browser Resources <i class='fa fa-cogs'></i>.",inferenceDelay:100,description:"This masking model operates on full T1 image in a single pass, but uses 11 filters per layer. Can work on dedicated graphics cards. Still more accurate than fast version."},{id:14,type:"Atlas",path:"/models/model21_104class/model.json",modelName:"ðŸ”ª Aparc+Aseg 104 (High Mem, Fast)",colormapPath:"./models/model21_104class/colormap.json",preModelId:1,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:200,enableTranspose:!0,enableCrop:!0,cropPadding:0,autoThreshold:0,enableQuantileNorm:!1,filterOutWithPreMask:!1,enableSeqConv:!1,textureSize:0,warning:"This model may need dedicated graphics card.  For more info please check with Browser Resources <i class='fa fa-cogs'></i>.",inferenceDelay:100,description:"FreeSurfer aparc+aseg atlas 104 parcellate brain areas into 104 regions. It contains a combination of the Desikan-Killiany atlas for cortical area and also segmentation of subcortical regions."},{id:15,type:"Atlas",path:"/models/model21_104class/model.json",modelName:"ðŸ”ª Aparc+Aseg 104 (Low Mem, Slow)",colormapPath:"./models/model21_104class/colormap.json",preModelId:null,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:200,enableTranspose:!0,enableCrop:!0,cropPadding:0,autoThreshold:0,enableQuantileNorm:!1,filterOutWithPreMask:!1,enableSeqConv:!0,textureSize:0,warning:"This model may need dedicated graphics card.  For more info please check with Browser Resources <i class='fa fa-cogs'></i>.",inferenceDelay:100,description:"FreeSurfer aparc+aseg atlas 104 parcellate brain areas into 104 regions. It contains a combination of the Desikan-Killiany atlas for cortical area and also segmentation of subcortical regions. The model use sequential convolution for inference to overcome browser memory limitations but leads to longer computation time. "},{id:16,type:"Brain_Extraction",path:"/models/mindgrab/model.json",modelName:"ðŸ§ ðŸª“ omnimodal Skull Strip (High Mem, Fast)",preModelId:null,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:0,enableTranspose:!0,enableCrop:!0,cropPadding:10,autoThreshold:0,enableQuantileNorm:!1,filterOutWithPreMask:!1,enableSeqConv:!1,textureSize:0,warning:"This model may need dedicated graphics card.  For more info please check with Browser Resources <i class='fa fa-cogs'></i>.",inferenceDelay:100,description:"Extract the brain high accuracy model operates on full T1 image in a single pass, but uses only 11 filters per layer. Can work on dedicated graphics cards. Still more accurate than the fast version."},{id:17,type:"Brain_Extraction",path:"/models/mindgrab/model.json",modelName:"ðŸ§ ðŸª“ omnimodal Skull Strip (Low Mem, Slow)",preModelId:null,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:0,enableTranspose:!0,enableCrop:!0,cropPadding:10,autoThreshold:0,enableQuantileNorm:!1,filterOutWithPreMask:!1,enableSeqConv:!0,textureSize:0,warning:"This model may need dedicated graphics card.  For more info please check with Browser Resources <i class='fa fa-cogs'></i>.",inferenceDelay:100,description:"Extract the brain high accuracy model operates on  image in a single pass, but uses only 11 filters per layer. Can work on dedicated graphics cards. Still more accurate than the fast version."}];class Je{idx(e,o,l,u){return l*u[0]*u[1]+o*u[0]+e}check_previous_slice(e,o,l,u,t,i,a,p,c,r){let h=0;if(!t)return 0;const m=e[this.idx(l,u,t,i)];if(a>=6){const d=this.idx(l,u,t-1,i);m===e[d]&&(c[h++]=o[d])}if(a>=18){if(l){const d=this.idx(l-1,u,t-1,i);m===e[d]&&(c[h++]=o[d])}if(u){const d=this.idx(l,u-1,t-1,i);m===e[d]&&(c[h++]=o[d])}if(l<i[0]-1){const d=this.idx(l+1,u,t-1,i);m===e[d]&&(c[h++]=o[d])}if(u<i[1]-1){const d=this.idx(l,u+1,t-1,i);m===e[d]&&(c[h++]=o[d])}}if(a===26){if(l&&u){const d=this.idx(l-1,u-1,t-1,i);m===e[d]&&(c[h++]=o[d])}if(l<i[0]-1&&u){const d=this.idx(l+1,u-1,t-1,i);m===e[d]&&(c[h++]=o[d])}if(l&&u<i[1]-1){const d=this.idx(l-1,u+1,t-1,i);m===e[d]&&(c[h++]=o[d])}if(l<i[0]-1&&u<i[1]-1){const d=this.idx(l+1,u+1,t-1,i);m===e[d]&&(c[h++]=o[d])}}return h?(this.fill_tratab(p,c,h,r),c[0]):0}do_initial_labelling(e,o,l){const u=new Uint32Array(32),t=new Uint32Array(32);let i=1;const a=8192;let p=a,c=new Uint32Array(p).fill(0);const r=new Uint32Array(o[0]*o[1]*o[2]).fill(0),h=new Uint32Array(27);for(let m=0;m<o[2];m++)for(let d=0;d<o[1];d++)for(let s=0;s<o[0];s++){let _=0;const M=e[this.idx(s,d,m,o)];if(M!==0){if(h[0]=this.check_previous_slice(e,r,s,d,m,o,l,c,u,t),h[0]&&(_+=1),l>=6){if(s){const f=this.idx(s-1,d,m,o);M===e[f]&&(h[_++]=r[f])}if(d){const f=this.idx(s,d-1,m,o);M===e[f]&&(h[_++]=r[f])}}if(l>=18){if(d&&s){const f=this.idx(s-1,d-1,m,o);M===e[f]&&(h[_++]=r[f])}if(d&&s<o[0]-1){const f=this.idx(s+1,d-1,m,o);M===e[f]&&(h[_++]=r[f])}}if(_)r[this.idx(s,d,m,o)]=h[0],this.fill_tratab(c,h,_,t);else{if(r[this.idx(s,d,m,o)]=i,i>=p){p+=a;const f=new Uint32Array(p);f.set(c),c=f}c[i-1]=i,i++}}}for(let m=0;m<i-1;m++){let d=m;for(;c[d]!==d+1;)d=c[d]-1;c[m]=d+1}return[i-1,c,r]}fill_tratab(e,o,l,u){let i=2147483647;for(let a=0;a<l;a++){let p=o[a];for(;e[p-1]!==p;)p=e[p-1];u[a]=p,i=Math.min(i,p)}for(let a=0;a<l;a++)e[u[a]-1]=i}translate_labels(e,o,l,u){const t=o[0]*o[1]*o[2];let i=0;const a=new Uint32Array(t).fill(0);for(let r=0;r<u;r++)i=Math.max(i,l[r]);const p=new Uint32Array(i).fill(0);let c=0;for(let r=0;r<t;r++)e[r]&&(p[l[e[r]-1]-1]||(c+=1,p[l[e[r]-1]-1]=c),a[r]=p[l[e[r]-1]-1]);return[c,a]}largest_original_cluster_labels(e,o,l){const u=e.length,t=new Uint32Array(o+1).fill(0),i=new Uint32Array(o+1).fill(0);for(let c=0;c<u;c++){const r=e[c],h=l[c];t[h]=r,i[h]++}let a=0;for(let c=0;c<o+1;c++){const r=t[c];a=Math.max(a,r);for(let h=0;h<o+1;h++)h!==c&&r===t[h]&&(i[c]<i[h]||i[c]===i[h]&&c<h)&&(t[c]=0)}const p=new Uint32Array(u).fill(0);for(let c=0;c<u;c++)p[c]=t[l[c]];return[a,p]}bwlabel(e,o,l=26,u=!1,t=!1){const i=Date.now(),a=o[0]*o[1]*o[2],p=new Uint32Array(a).fill(0);if(![6,18,26].includes(l))return[0,p];if(o[0]<2||o[1]<2||o[2]<1)return[0,p];if(u)for(let s=0;s<a;s++)e[s]!==0&&(p[s]=1);else p.set(e);let[c,r,h]=this.do_initial_labelling(p,o,l);r===void 0&&(r=new Uint32Array(0));const[m,d]=this.translate_labels(h,o,r,c);if(t){const[s,_]=this.largest_original_cluster_labels(p,m,d);return[s,_]}return[m,d]}}function Ae(u){return w(this,arguments,function*(n,e=[1,1],o=[1,1],l=[1,1]){if(n.rank!==3)throw new Error("Tensor must be 3D");return n.pad([e,o,l])})}function Ee(n,e){return w(this,null,function*(){const o=n.max(),l=o.mul(e),u=yield l.data();return o.dispose(),l.dispose(),$(()=>n.clone().greater(u[0]))})}function me(n){return w(this,null,function*(){return n.step(0)})}function Ye(n,e=.01,o=.99){return w(this,null,function*(){const l=n.flatten(),u=yield l.array();u.sort((d,s)=>d-s);const t=Ce(u),i=t.shape[0],a=Math.floor(i*e),p=Math.ceil(i*o)-1,c=t.slice(a,1),r=t.slice(p,1),h=(yield c.array())[0],m=(yield r.array())[0];return l.dispose(),t.dispose(),c.dispose(),r.dispose(),{qmin:h,qmax:m}})}function De(n,e,o,l,u,t,i){return w(this,null,function*(){const a=n.shape[4],p=e.shape[4];let c=null;for(let r=0;r<p;r++){const h=Math.ceil(a/i);let m=null;for(let s=0;s<h;s++){const _=s*i,M=Math.min((s+1)*i,a);if(_<a){const f=$(()=>{const g=n.slice([0,0,0,0,_],[-1,-1,-1,-1,M-_]),y=e.slice([0,0,0,_,r],[-1,-1,-1,M-_,1]);return fe(g,y,l,u,"NDHWC",t)});if(m===null)m=f;else{const g=m.add(f);m.dispose(),f.dispose(),m=g}}}let d;if(o){const s=o.slice([r],[1]);d=m.add(s),m.dispose(),s.dispose()}else d=m;if(c==null)c=d;else{const s=yield Pe([c,d],4);d.dispose(),c.dispose(),c=s}}return c})}function eo(n,e=1e-5){return $(()=>{const{mean:o,variance:l}=Oe(n,[1,2,3],!0),u=Ie(l.add(e));return n.sub(o).mul(u)})}function oo(n,e,o,l,u,t,i){return w(this,null,function*(){const a=n.shape[4],p=e.shape[4],c=[];for(let h=0;h<p;h++){const m=Math.ceil(a/i);let d=null;for(let M=0;M<m;M++){const f=M*i,g=Math.min((M+1)*i,a);if(f<a){const y=$(()=>{const x=n.slice([0,0,0,0,f],[-1,-1,-1,-1,g-f]),L=e.slice([0,0,0,f,h],[-1,-1,-1,g-f,1]);return fe(x,L,l,u,"NDHWC",t)});if(d===null)d=y;else{const x=d.add(y);d.dispose(),y.dispose(),d=x}}}let s;if(o){const M=o.slice([h],[1]);s=d.add(M),d.dispose(),M.dispose()}else s=d;const _=eo(s);c.push(_),s.dispose()}const r=Pe(c,4);return c.forEach(h=>h.dispose()),r})}function no(n,e=1e-5){const o=$(()=>{const{mean:l,variance:u}=Oe(n,[1,2,3],!0),t=Ie(u.add(e));return n.sub(l).mul(t)});return n.dispose(),o}function Ne(n,e,o,l){return w(this,null,function*(){const u=[];for(let c=0;c<n.length;c++)u[c]=Array.from(n[c].dataSync());const t=new Array(u[0].length*u.length);let i=0;for(let c=0;c<u.length;c++)for(let r=0;r<u[c].length;r++)t[i++]=u[c][r];const a=yield me(Ce(t)),p=Array.from(a.dataSync());l(p,e,o)})}function de(n,e=0){return w(this,null,function*(){let o=[];e===0?o=yield n.max(2).max(1).arraySync():e===1?o=yield n.max(2).max(0).arraySync():o=yield n.max(1).max(0).arraySync();let l=o.length,u=0;for(let t=0;t<o.length;t++)if(o[t]>0){l=t;break}for(let t=o.length-1;t>=0;t--)if(o[t]>0){u=t;break}return[l,u]})}function Fe(n){return w(this,null,function*(){const[e,o]=yield de(n,0),[l,u]=yield de(n,1),[t,i]=yield de(n,2);return[e,o,l,u,t,i]})}function ao(n,e,o,l,u,t,i,a,p=!0){return w(this,null,function*(){n[0].dtype!=="int32"&&i("",-1,"generateBrainMask assumes int32"),u.preModelPostProcess&&i("",-1,"generateBrainMask assumes BWLabeler instead of preModelPostProcess");const c=n.length,r=n[0].size,h=c*r,m=new Int32Array(h);let d=0;for(let s=0;s<c;s++)m.set(n[s].dataSync(),d),d+=r;for(let s=0;s<h;s++)m[s]=m[s]!==0?1:0;return(p||t.showPhase1Output)&&(a(m,t,u),i("Segmentation finished",0)),ae(m,[e,o,l])})}function Ve(n,e,o,l,u,t,i,a,p,c){return w(this,null,function*(){if(p.isPostProcessEnable){const h=new Je,m=new Uint32Array(e),d=26,s=!0,_=!0,[M,f]=h.bwlabel(n,m,d,s,_);for(let g=0;g<n.length;g++)n[g]*=f[g]}const r=new Uint8Array(n);switch(a.type){case"Brain_Masking":{const h=new Uint8Array(r.length);for(let m=0;m<r.length;m++)h[m]=r[m]!==0?1:0;return h}case"Brain_Extraction":{const h=new Uint8Array(r.length);for(let m=0;m<r.length;m++){const d=r[m]!==0?1:0;h[m]=c[m]*d}return h}}return n})}function ro(n,e,o){return w(this,null,function*(){const l=e.dims[1],u=e.dims[2];let t;if(e.datatypeCode===2)t=new Uint8Array(o);else if(e.datatypeCode===4)t=new Int16Array(o);else if(e.datatypeCode===8)t=new Int32Array(o);else if(e.datatypeCode===16)t=new Float32Array(o);else if(e.datatypeCode===64)t=new Float64Array(o);else if(e.datatypeCode===256)t=new Int8Array(o);else if(e.datatypeCode===512)t=new Uint16Array(o);else if(e.datatypeCode===768)t=new Uint32Array(o);else return;const i=[];let a=0;for(let c=0;c<n;c++){const r=new Array(u*l);let h=0;for(let m=0;m<u;m++)for(let d=0;d<l;d++){const s=t[a++];r[h++]=s&255}i.push(ae(r,[u,l]))}const p=Ge(i);return Q(i),p})}function ge(n){return w(this,null,function*(){return n.layers.length})}function ye(n){return w(this,null,function*(){let e=0;for(let o=0;o<n.layers.length;o++)e+=n.layers[o].countParams();return e})}function te(n){return w(this,null,function*(){for(let e=0;e<n.layers.length;e++)if(n.layersByDepth[e][0].dataFormat)return n.layersByDepth[e][0].dataFormat==="channelsLast"})}function We(n){return w(this,null,function*(){return yield ze(n)})}function we(n){return w(this,null,function*(){const e=n.max(),o=n.min();return yield n.sub(o).div(e.sub(o))})}function so(n,e,o){const i=n.shape[4],a=Math.ceil(i/o);let p=null;for(let c=0;c<a;c++){const r=c*o,m=Math.min((c+1)*o,i)-r,d=$(()=>n.slice([0,0,0,0,r],[-1,-1,-1,-1,m])),s=$(()=>e.slice([0,0,0,r,0],[-1,-1,-1,m,-1])),_=fe(d,s,1,0,"NDHWC",1);d.dispose(),s.dispose();const M=Xe(_);if(_.dispose(),p===null)p=M;else{const f=p.add(M);p.dispose(),p!==M&&M.dispose(),p=f}$(()=>{Le(pe([1,1]),pe([1,1]))})}return p}function be(n,e=.05,o=.95){return w(this,null,function*(){const{qmin:l,qmax:u}=yield Ye(n,e,o),t=xe(l),i=xe(u),a=n.sub(t).div(i.sub(t));return t.dispose(),i.dispose(),a})}function re(n,e=1,o=1,l=1){return w(this,null,function*(){if(n.rank!==3)throw new Error("Tensor must be 3D");const[u,t,i]=n.shape;return n.slice([e,o,l],[u-2*e,t-2*o,i-2*l])})}function se(n,e,o,l,u,t){return w(this,null,function*(){const i=u[0],a=u[1],p=u[2],c=i+t[0]-1,r=a+t[1]-1,h=p+t[2]-1,m=o-c-1>0?o-c-1:0,d=l-r-1>0?l-r-1:0,s=e-h-1>0?e-h-1:0;return n.pad([[i,m],[a,d],[p,s]])})}class to{constructor(e,o,l,u,t=!0){this.model=e,this.outChannels=e.outputLayers[0].kernel.shape[4],this.chunkSize=o,this.isChannelLast=l,this.callbackUI=u,this.isWebWorker=t}apply(e){return w(this,null,function*(){const o=ie.get("WEBGL_DELETE_TEXTURE_THRESHOLD");ie.set("WEBGL_DELETE_TEXTURE_THRESHOLD",0);const l=this,u=performance.now(),t=l.model.layers[l.model.layers.length-1],i=t.getWeights()[0],a=t.getWeights()[1],p=l.isChannelLast?e.shape.slice(1,-1):e.shape.slice(2);let c=je(ce(p),-1e4),r=pe(p),h=0;for(;;){I().startScope();const m=yield $(()=>{const s=i.slice([0,0,0,0,h],[-1,-1,-1,-1,1]),_=a.slice([h],[1]),M=so(e,s,Math.min(l.chunkSize,l.outChannels)).add(_),f=Qe(M,c),g=_e(f,M,c),y=_e(f,He(r.shape,h),r);return Q([c,r,s,_,M,f]),$(()=>Le(ce([1,1]),ce([1,1]))),[y,g]});if(l.callbackUI(`Iteration ${h}`,h/l.outChannels),l.isWebWorker||(yield new Promise(s=>setTimeout(s,17))),(yield D()).unreliable,typeof r!="undefined"&&r.dispose(),typeof c!="undefined"&&c.dispose(),r=Me(m[0]),c=Me(m[1]),I().endScope(),h===l.outChannels-1){Q(c);const _=performance.now()-u;return ie.set("WEBGL_DELETE_TEXTURE_THRESHOLD",o),r}else{h++;const s=r.shape,_=r.dataSync(),M=r.shape,f=c.dataSync();r.dispose(),c.dispose(),r=ae(_,s),c=ae(f,M)}}})}}function Te(n,e,o,l,u,t,i,a,p,c,r,h){return w(this,null,function*(){e.enableQuantileNorm?l=yield be(l):l=yield we(l);let d;if(a==null){const A=e.autoThreshold;A>0&&A<=1?d=yield Ee(l,A):d=yield l.greater([0]).asType("bool")}else d=yield a.greater([0]).asType("bool");const[s,_,M,f,g,y]=yield Fe(d);d.dispose();const x=[s,M,g],L=[_-s+1,f-M+1,y-g+1],C=yield l.slice([s,M,g],[_-s+1,f-M+1,y-g+1]);l.dispose();const S=e.cropPadding;let P=yield Ae(C,[S,S],[S,S],[S,S]);if(C.dispose(),n.drawBoundingVolume){let A=yield re(P,S,S,S);return A=yield se(A,u,t,i,x,L),Ne(he(A),n,e,c),A.dispose(),0}r.Brainchop_Ver="FullVolume";const b=yield o;try{let A=performance.now();const X=performance.now();let B=0;const O=e.enableTranspose,ee=e.inferenceDelay;O&&(P=yield P.transpose());let T=1;const K=b.layers.length,v=te(b),U=n.batchSize,q=n.numOfChan;let Z;v?(b.layers[0].batchInputShape[1]=P.shape[0],b.layers[0].batchInputShape[2]=P.shape[1],b.layers[0].batchInputShape[3]=P.shape[2],Z=[U,b.layers[0].batchInputShape[1],b.layers[0].batchInputShape[2],b.layers[0].batchInputShape[3],q]):(b.layers[0].batchInputShape[2]=P.shape[0],b.layers[0].batchInputShape[3]=P.shape[1],b.layers[0].batchInputShape[4]=P.shape[2],Z=[U,q,b.layers[0].batchInputShape[2],b.layers[0].batchInputShape[3],b.layers[0].batchInputShape[4]]),r.Input_Shape=JSON.stringify(b.layers[0].batchInputShape),r.Output_Shape=JSON.stringify(b.output.shape),r.Channel_Last=v,r.Model_Param=yield ye(b),r.Model_Layers=yield ge(b),r.Model=e.modelName,r.Seq_Conv=e.enableSeqConv,r.Extra_Info=null;const J=b.layers[b.layers.length-1],W=v?J.outputShape[J.outputShape.length-1]:J.outputShape[1],N=[];N[0]=yield P.reshape(Z);const V=window.setInterval(function(){return w(this,null,function*(){try{b.layers[T].activation.getClassName()!=="linear"?N[T]=yield b.layers[T].apply(N[T-1]):b.layers[T].name.endsWith("_gn")?N[T]=yield oo(N[T-1],b.layers[T].getWeights()[0],b.layers[T].getWeights()[1],b.layers[T].strides,b.layers[T].padding,b.layers[T].dilationRate,3):N[T]=yield De(N[T-1],b.layers[T].getWeights()[0],b.layers[T].getWeights()[1],b.layers[T].strides,b.layers[T].padding,b.layers[T].dilationRate,3),Q(N[T-1])}catch(k){const R="Your graphics card (e.g. Intel) may not be compatible with WebGL. "+k.message;return p(R,-1,R),window.clearInterval(V),I().endScope(),I().disposeVariables(),r.Inference_t=1/0,r.Postprocess_t=1/0,r.Status="Fail",r.Error_Type=k.message,r.Extra_Err_Info="Failed while model layer "+T+" apply",p("",-1,"",r),0}if(b.layers[T].dispose(),N[T-1].dispose(),p("Layer "+T.toString(),(T+1)/K),D().unreliable){const k="unreliable reasons :"+D().reasons;p(k,NaN,k)}if(T===K-2){window.clearInterval(V);const R=yield(yield new to(b,10,v,p,!1)).apply(N[T]);if(p("seqConvLayer Done"),Q(N[T]),R.shape.length!==3){const F="Output tensor shape should be 3 dims but it is "+R.shape.length;p(F,-1,F)}const z=yield R.max().dataSync()[0],G=((performance.now()-A)/1e3).toFixed(4);B<z&&(B=z);const j=B+1;if(r.Actual_Labels=j,r.Expect_Labels=W,r.NumLabels_Match=j===W,j!==W){const F="expected "+W+" labels, but the predicted are "+j;p(F,-1,F)}let E=R.reshape([P.shape[0],P.shape[1],P.shape[2]]);Q(R),O&&(E=E.transpose()),E=yield re(E,S,S,S),E=yield se(E,u,t,i,x,L);const le=e.filterOutWithPreMask;if(a!=null&&n.isBrainCropMaskBased&&le){const F=yield me(a);E=yield E.mul(F)}A=performance.now();let ne;try{const F=yield new Uint32Array(E.dataSync()),Y=E.shape,Re=E.dtype;ne=yield Ve(F,Y,Re,u,j,t,i,e,n,h),Q(E),I().endScope(),I().disposeVariables()}catch(F){I().endScope(),I().disposeVariables();const Y="Failed while generating output due to limited browser memory available";return p(Y,-1,Y),r.Inference_t=G,r.Postprocess_t=1/0,r.Status="Fail",r.Error_Type=F.message,r.Extra_Err_Info="Failed while generating output",p("",-1,"",r),0}const H=((performance.now()-A)/1e3).toFixed(4);return r.Inference_t=G,r.Postprocess_t=H,r.Status="OK",p("",-1,"",r),p("Segmentation finished",0),c(ne,n,e),0}else T++})},ee)}catch(A){if(p(A.message,-1,A.message),D().unreliable){const X="unreliable reasons :"+D().reasons;p(X,NaN,X)}}})}function ve(n,e,o,l,u,t,i,a,p,c,r,h){return w(this,null,function*(){let m=[];i.enableQuantileNorm?e=yield be(e):e=yield we(e);let s;if(t==null){const O=i.autoThreshold;O>0&&O<=1?s=yield Ee(e,O):s=yield e.greater([0]).asType("bool")}else s=t.greater([0]).asType("bool");const[_,M,f,g,y,x]=yield Fe(s);s.dispose();const L=[_,f,y],C=[M-_+1,g-f+1,x-y+1],S=e.slice([_,f,y],[M-_+1,g-f+1,x-y+1]);e.dispose();const P=i.cropPadding;let b=yield Ae(S,[P,P],[P,P],[P,P]);if(S.dispose(),p.drawBoundingVolume){let O=yield re(b,P,P,P);return O=yield se(O,o,l,u,L,C),Ne(he(O),p,i,c),O.dispose(),0}a.Brainchop_Ver="FullVolume";let A=performance.now(),X=[];const B=yield n;try{A=performance.now();const O=performance.now();let ee=0;const T=i.enableTranspose,K=i.inferenceDelay;T&&(b=b.transpose());let v=1;const U=B.layers.length,q=yield te(B),Z=p.batchSize,J=p.numOfChan;q?(B.layers[0].batchInputShape[1]=b.shape[0],B.layers[0].batchInputShape[2]=b.shape[1],B.layers[0].batchInputShape[3]=b.shape[2],X=[Z,B.layers[0].batchInputShape[1],B.layers[0].batchInputShape[2],B.layers[0].batchInputShape[3],J]):(B.layers[0].batchInputShape[2]=b.shape[0],B.layers[0].batchInputShape[3]=b.shape[1],B.layers[0].batchInputShape[4]=b.shape[2],X=[Z,J,B.layers[0].batchInputShape[2],B.layers[0].batchInputShape[3],B.layers[0].batchInputShape[4]]),a.Input_Shape=JSON.stringify(B.layers[0].batchInputShape),a.Output_Shape=JSON.stringify(B.output.shape),a.Channel_Last=q,a.Model_Param=yield ye(B),a.Model_Layers=yield ge(B),a.Model=i.modelName,a.Extra_Info=null;const W=[];W[0]=b.reshape(X);const N=window.setInterval(function(){return w(this,null,function*(){try{let V=yield B.layers[v].apply(W[v-1]);B.layers[v].name.endsWith("_gn")&&(V=no(V)),W[v]=V}catch(V){return r(V.message,-1,V.message),window.clearInterval(N),I().endScope(),I().disposeVariables(),a.Inference_t=1/0,a.Postprocess_t=1/0,a.Status="Fail",a.Error_Type=V.message,a.Extra_Err_Info="Failed while model layer "+v+" apply",r("",-1,"",a),0}if(r("Layer "+v.toString(),(v+1)/U),B.layers[v].dispose(),W[v-1].dispose(),D().unreliable){const V="unreliable reasons :"+D().reasons;r(V,NaN,V)}if(v===U-1){window.clearInterval(N);const V=q?-1:1,k=q?W[v].shape[4]:W[v].shape[1];let R;try{const H=performance.now();R=Be(W[v],V)}catch(H){if(V===-1)try{const F=performance.now();window.alert("tensor2LightBuffer() is not dead code?"),window.alert("argMaxLarge() is not dead code?")}catch(F){const Y="argMax buffer couldn't be created due to limited memory resources.";return r(Y,-1,Y),window.clearInterval(N),I().endScope(),I().disposeVariables(),a.Inference_t=1/0,a.Postprocess_t=1/0,a.Status="Fail",a.Error_Type=F.message,a.Extra_Err_Info="prediction_argmax from argMaxLarge failed",r("",-1,"",a),0}else{const F="argMax buffer couldn't be created due to limited memory resources.";return r(F,-1,F),R.dispose(),window.clearInterval(N),I().endScope(),I().disposeVariables(),a.Inference_t=1/0,a.Postprocess_t=1/0,a.Status="Fail",a.Error_Type=H.message,a.Extra_Err_Info="prediction_argmax from argMaxLarge not support yet channel first",r("",-1,"",a),0}}const z=((performance.now()-A)/1e3).toFixed(4);Q(W[v]);const G=yield R.max().dataSync()[0];ee<G&&(ee=G);const j=ee+1;if(a.Actual_Labels=j,a.Expect_Labels=k,a.NumLabels_Match=j===k,j!==k){const H="expected "+k+" labels, but the predicted are "+j;r(H,-1,H)}let E=R.reshape([b.shape[0],b.shape[1],b.shape[2]]);Q(R),T&&(E=E.transpose()),E=yield re(E,P,P,P),E=yield se(E,o,l,u,L,C);const le=i.filterOutWithPreMask;if(t!=null&&p.isBrainCropMaskBased&&le){const H=me(t);E=E.mul(H)}A=performance.now();try{const H=new Uint32Array(E.dataSync()),F=E.shape,Y=E.dtype;Q(E),I().endScope(),I().disposeVariables(),m=yield Ve(H,F,Y,o,j,l,u,i,p,h)}catch(H){I().endScope(),I().disposeVariables();const F="Failed while generating output due to limited browser memory available";return r(F,-1,F),a.Inference_t=z,a.Postprocess_t=1/0,a.Status="Fail",a.Error_Type=H.message,a.Extra_Err_Info="Failed while generating output",r("",-1,"",a),0}const ne=((performance.now()-A)/1e3).toFixed(4);return I().disposeVariables(),a.Inference_t=z,a.Postprocess_t=ne,a.Status="OK",r("",-1,"",a),clearInterval(N),r("Segmentation finished",0),c(m,p,i),0}v++})},K)}catch(O){r(O.message,-1,O.message)}})}function lo(n,e,o,l,u,t,i,a,p,c,r,h){return w(this,null,function*(){if(a.No_SubVolumes=1,i.preModelId){const m=yield We(p.rootURL+oe[i.preModelId-1].path),d=oe[i.preModelId-1].enableTranspose,s=oe[i.preModelId-1].enableQuantileNorm;let _=null;s?_=yield be(e):_=yield we(e),d&&(_=yield _.transpose()),a.Brainchop_Ver="PreModel_FV";const M=yield m;try{const f=performance.now(),g=M,y=g.layers[0].batchInputShape;if(y.length!==5){const v="The pre-model input shape must be 5D ";return r(v,-1,v),0}const x=te(g),L=p.batchSize,C=p.numOfChan;let S,P,b,A;if(x){if(isNaN(y[4])||y[4]!==1){const v="The number of channels for pre-model input shape must be 1";return r(v,-1,v),0}S=y[1],P=y[2],b=y[3],A=[L,S,P,b,C]}else{if(isNaN(y[1])||y[1]!==1){const v="The number of channels for pre-model input shape must be 1";return r(v,-1,v),0}S=y[2],P=y[3],b=y[4],A=[L,C,S,P,b]}a.Input_Shape=JSON.stringify(A),a.Output_Shape=JSON.stringify(g.output.shape),a.Channel_Last=x,a.Model_Param=yield ye(g),a.Model_Layers=yield ge(g);let X=0;const B=oe[i.preModelId-1].inferenceDelay;let O=1;const ee=M.layers.length,T=[];T[0]=_.reshape(A),Q(_);const K=window.setInterval(function(){return w(this,null,function*(){try{T[O]=yield M.layers[O].apply(T[O-1])}catch(v){const U="Your graphics card (e.g. Intel) may not be compatible with WebGL. "+v.message;return r(U,-1,U),window.clearInterval(K),I().endScope(),I().disposeVariables(),a.Inference_t=1/0,a.Postprocess_t=1/0,a.Status="Fail",a.Error_Type=v.message,a.Extra_Err_Info="PreModel Failed while model layer "+O+" apply",r("",-1,"",a),0}if(M.layers[O].dispose(),T[O-1].dispose(),r("Layer "+O.toString(),(O+1)/ee),D().unreliable){const v="unreliable reasons :"+D().reasons;r(v,NaN,v)}if(O===ee-1){window.clearInterval(K);const v=x?-1:1,U=x?T[O].shape[4]:T[O].shape[1];let q;try{q=yield Be(T[O],v)}catch(z){if(v===-1)try{const G=performance.now();window.alert("tensor2LightBuffer() is not dead code?"),window.alert("argMaxLarge() is not dead code?")}catch(G){const j="argMax buffer couldn't be created due to limited memory resources.";return r(j,-1,j),q.dispose(),window.clearInterval(K),I().endScope(),I().disposeVariables(),a.Inference_t=1/0,a.Postprocess_t=1/0,a.Status="Fail",a.Error_Type=G.message,a.Extra_Err_Info="preModel prediction_argmax from argMaxLarge failed",r("",-1,"",a),0}else{const G="argMax buffer couldn't be created due to limited memory resources.";return r(G,-1,G),q.dispose(),window.clearInterval(K),I().endScope(),I().disposeVariables(),a.Inference_t=1/0,a.Postprocess_t=1/0,a.Status="Fail",a.Error_Type=z.message,a.Extra_Err_Info="preModel prediction_argmax from argMaxLarge not support yet channel first",r("",-1,"",a),0}}const Z=((performance.now()-f)/1e3).toFixed(4);Q(T[O]);const J=yield q.max().dataSync()[0];X<J&&(X=J);const W=X+1;a.Actual_Labels=W,a.Expect_Labels=U,a.NumLabels_Match=W===U;let N=yield q.reshape([o,l,u]);Q(q),d&&(N=N.transpose());const V=performance.now();let k;try{const z=yield he(N);k=yield ao(z,o,l,u,i,p,r,c,!1),yield Q(N)}catch(z){I().endScope(),I().disposeVariables();const G="Failed while generating pre-model output due to limited browser memory available";return r(G,-1,G),a.Inference_t=Z,a.Postprocess_t=1/0,a.Status="Fail",a.Error_Type=z.message,a.Extra_Err_Info="Pre-model failed while generating output",r("",-1,"",a),0}const R=((performance.now()-V)/1e3).toFixed(4);if(a.Inference_t=Z,a.Postprocess_t=R,a.Status="OK",r("",-1,"",a),k==null){const z="slice_3d_mask failed ...";return r(z,-1,z),0}else if(t){if(i.enableSeqConv)return yield Te(p,i,n,e,o,l,u,k,r,c,a,h),0;yield ve(n,e,o,l,u,k,i,a,p,c,r,h)}else window.alert("inferenceSubVolumes() is not dead code?")}O++})},B)}catch(f){r(f.message,-1,f.message)}}else t?i.enableSeqConv?yield Te(p,i,n,e,o,l,u,null,r,c,a,h):ve(n,e,o,l,u,null,i,a,p,c,r,h):window.alert("inferenceSubVolumes() is not dead code?")})}function io(n=!0){return w(this,null,function*(){yield $e(),ue().set("DEBUG",!1),ue().set("WEBGL_FORCE_F16_TEXTURES",n),ue().set("WEBGL_DELETE_TEXTURE_THRESHOLD",-1),yield Ke()})}function co(n,e,o,l,u,t){return w(this,null,function*(){const i=[];i.startTime=Date.now(),t("Segmentation started",0),performance.now();const a=n.batchSize,p=n.numOfChan;if(isNaN(a)||a!==1){const S="The batch Size for input shape must be 1";return t(S,-1,S),0}if(isNaN(p)||p!==1){const S="The number of channels for input shape must be 1";return t(S,-1,S),0}I().startScope();const c=yield We(n.rootURL+e.path);yield io(!0),i.TF_Backend=Ue();const r=c;let h=[];if(h=r.layers[0].batchInputShape,h.length!==5){const S="The model input shape must be 5D";return t(S,-1,S),0}let m,d,s;const _=o.dims[1],M=o.dims[2],f=o.dims[3];if(yield te(r)){if(isNaN(h[4])||h[4]!==1){const S="The number of channels for input shape must be 1";return t(S,-1,S),0}m=h[1],d=h[2],s=h[3]}else{if(isNaN(h[1])||h[1]!==1){const S="The number of channels for input shape must be 1";return t(S,-1,S),0}m=h[2],d=h[3],s=h[4]}let y;m===256&&d===256&&s===256?y=!0:y=!1,i.isModelFullVol=y;let x=yield ro(f,o,l);const L=e.enableTranspose,C=e.enableCrop;y&&(C?yield lo(c,x,f,M,_,y,e,i,n,u,t,l):(L&&(x=x.transpose()),e.enableSeqConv?window.alert("inferenceFullVolumeSeqCovLayer() is not dead code?"):window.alert("inferenceFullVolume() is not dead code?")))})}function Se(){return w(this,null,function*(){return navigator.userAgent.indexOf("OPR/")>-1?"Opera":navigator.userAgent.indexOf("Edg/")>-1?"Edge":navigator.userAgent.indexOf("Falkon/")>-1?"Falkon":navigator.userAgent.indexOf("Chrome/")>-1?"Chrome":navigator.userAgent.indexOf("Firefox/")>-1?"Firefox":navigator.userAgent.indexOf("Safari/")>-1?"Safari":navigator.userAgent.indexOf("MSIE/")>-1||navigator.userAgent.indexOf("rv:")>-1?"IExplorer":"Unknown"})}function uo(){return w(this,null,function*(){return navigator.userAgent.indexOf("OPR/")>-1?parseInt(navigator.userAgent.split("OPR/")[1]):navigator.userAgent.indexOf("Edg/")>-1?parseInt(navigator.userAgent.split("Edg/")[1]):navigator.userAgent.indexOf("Falkon/")>-1?parseInt(navigator.userAgent.split("Falkon/")[1]):navigator.userAgent.indexOf("Chrome/")>-1?parseInt(navigator.userAgent.split("Chrome/")[1]):navigator.userAgent.indexOf("Firefox/")>-1?parseInt(navigator.userAgent.split("Firefox/")[1]):navigator.userAgent.indexOf("Safari/")>-1?parseInt(navigator.userAgent.split("Safari/")[1]):navigator.userAgent.indexOf("MSIE/")>-1||navigator.userAgent.indexOf("rv:")>-1?parseInt(navigator.userAgent.split("MSIE/")[1]):1/0})}function po(){return w(this,null,function*(){return navigator.userAgent.indexOf("Win")>-1?"Windows":navigator.userAgent.indexOf("Mac")>-1?"MacOS":navigator.userAgent.indexOf("Linux")>-1?"Linux":navigator.userAgent.indexOf("UNIX")>-1?"UNIX":"Unknown"})}function fo(n){return w(this,null,function*(){return!!n})}function ho(n){return w(this,null,function*(){let e;if(n&&(e=n.getExtension("WEBGL_debug_renderer_info"),e)){const o=n.getParameter(e.UNMASKED_VENDOR_WEBGL);return o.indexOf("(")>-1&&o.indexOf(")")>-1?o.substring(o.indexOf("(")+1,o.indexOf(")")):o}return null})}function mo(n){return w(this,null,function*(){if(n){const e=n.getExtension("WEBGL_debug_renderer_info");return e?n.getParameter(e.UNMASKED_VENDOR_WEBGL):null}else return null})}function go(n){return w(this,null,function*(){if(n){if(Se()==="Firefox")return n.getParameter(n.RENDERER);const e=n.getExtension("WEBGL_debug_renderer_info");return e?n.getParameter(e.UNMASKED_RENDERER_WEBGL):null}else return null})}function yo(n){return w(this,null,function*(){let e;if(n){if(Se()==="Firefox")return n.getParameter(n.RENDERER);if(e=n.getExtension("WEBGL_debug_renderer_info"),e){let o=n.getParameter(e.UNMASKED_RENDERER_WEBGL);return o.indexOf("(")>-1&&o.indexOf(")")>-1&&o.indexOf("(R)")===-1&&(o=o.substring(o.indexOf("(")+1,o.indexOf(")")),o.split(",").length===3)?o.split(",")[1].trim():o}}return null})}function wo(){return w(this,null,function*(){return navigator.hardwareConcurrency})}function ke(){return w(this,null,function*(){return/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)})}function bo(n,e=null){return w(this,null,function*(){const o=new Date;if(n.isModelFullVol?n.Brainchop_Ver="FullVolume":n.Brainchop_Ver="SubVolumes",n.Total_t=(Date.now()-n.startTime)/1e3,delete n.startTime,n.Date=parseInt(o.getMonth()+1)+"/"+o.getDate()+"/"+o.getFullYear(),n.Browser=yield Se(),n.Browser_Ver=yield uo(),n.OS=yield po(),n.WebGL2=yield fo(e),n.GPU_Vendor=yield ho(e),n.GPU_Card=yield yo(e),n.GPU_Vendor_Full=yield mo(e),n.GPU_Card_Full=yield go(e),n.CPU_Cores=yield wo(),n.Which_Brainchop="latest",(yield ke())&&(n.Heap_Size_MB=window.performance.memory.totalJSHeapSize/(1024*1024).toFixed(2),n.Used_Heap_MB=window.performance.memory.usedJSHeapSize/(1024*1024).toFixed(2),n.Heap_Limit_MB=window.performance.memory.jsHeapSizeLimit/(1024*1024).toFixed(2)),e){const l=e.getExtension("WEBGL_debug_renderer_info");n.Texture_Size=e.getParameter(e.MAX_TEXTURE_SIZE)}else n.Texture_Size=null;return n})}function So(n){return new Worker("/assets/brainchop-webworker-Bz7ltmXu.js",{name:n==null?void 0:n.name})}function xo(){return w(this,null,function*(){dragMode.onchange=function(){return w(this,null,function*(){s.opts.dragMode=this.selectedIndex})},drawDrop.onchange=function(){return w(this,null,function*(){if(s.volumes.length<2){window.alert("No segmentation open (use the Segmentation pull down)"),drawDrop.selectedIndex=-1;return}if(!s.drawBitmap){window.alert("No drawing (hint: use the Draw pull down to select a pen)"),drawDrop.selectedIndex=-1;return}const f=parseInt(this.value);if(f===0){s.drawUndo(),drawDrop.selectedIndex=-1;return}let g=s.volumes[1].img,y=yield s.saveImage({filename:"",isSaveDrawing:!0});const x=352,L=y.length;if(f===1)for(let C=0;C<L;C++)y[x+C]>0&&(g[C]=1);if(f===2)for(let C=0;C<L;C++)y[x+C]>0&&(g[C]=0);s.closeDrawing(),s.updateGLVolume(),s.setDrawingEnabled(!1),penDrop.selectedIndex=-1,drawDrop.selectedIndex=-1})},penDrop.onchange=function(){return w(this,null,function*(){const f=parseInt(this.value);s.setDrawingEnabled(f>=0),f>=0&&s.setPenValue(f&7,f>7)})},aboutBtn.onclick=function(){window.alert("Drag and drop NIfTI images. Use pulldown menu to choose brainchop model")},diagnosticsBtn.onclick=function(){if(h.length<1){window.alert("No diagnostic string generated: run a model to create diagnostics");return}m=m.slice(0,-2),m!==""&&h.includes("Status: OK")&&(h=h.replace("Status: OK",`Status: ${m}`)),m="",navigator.clipboard.writeText(h),window.alert(`Diagnostics copied to clipboard
`+h)},opacitySlider0.oninput=function(){s.setOpacity(0,opacitySlider0.value/255),s.updateGLVolume()},opacitySlider1.oninput=function(){s.setOpacity(1,opacitySlider1.value/255)};function n(){return w(this,null,function*(){const f=s.volumes[0];let g=f.dims[1]===256&&f.dims[2]===256&&f.dims[3]===256&&f.img instanceof Uint8Array&&f.img.length===256*256*256;if((f.permRAS[0]!==-1||f.permRAS[1]!==3||f.permRAS[2]!==-2)&&(g=!1),g)return;const y=yield s.conform(f,!1);yield s.removeVolume(s.volumes[0]),yield s.addVolume(y)})}function e(){return w(this,null,function*(){for(;s.volumes.length>1;)yield s.removeVolume(s.volumes[1])})}modelSelect.onchange=function(){return w(this,null,function*(){this.selectedIndex<0&&(modelSelect.selectedIndex=11),yield e(),yield n();const f=oe[this.selectedIndex],g=Ze,y=new URL(window.location.href);if(g.rootURL=y.origin+y.pathname,!!(window.location.hostname==="localhost"||window.location.hostname==="[::1]"||window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/))&&(g.rootURL=location.protocol+"//"+location.host),workerCheck.checked){if(typeof d!="undefined")return;d=yield new So({});const L={datatypeCode:s.volumes[0].hdr.datatypeCode,dims:s.volumes[0].hdr.dims},C={opts:g,modelEntry:f,niftiHeader:L,niftiImage:s.volumes[0].img};d.postMessage(C),d.onmessage=function(S){const P=S.data.cmd;P==="ui"&&(S.data.modalMessage!==""&&(d.terminate(),d=void 0),p(S.data.message,S.data.progressFrac,S.data.modalMessage,S.data.statData)),P==="img"&&(d.terminate(),d=void 0,i(S.data.img,S.data.opts,S.data.modelEntry))}}else co(g,f,s.volumes[0].hdr,s.volumes[0].img,i,p)})},saveImgBtn.onclick=function(){s.volumes[1].saveToDisk("segmentaion.nii.gz")},saveSceneBtn.onclick=function(){s.saveDocument("brainchop.nvd")},workerCheck.onchange=function(){modelSelect.onchange()},clipCheck.onchange=function(){clipCheck.checked?s.setClipPlane([0,0,90]):s.setClipPlane([2,0,90])};function o(){opacitySlider0.oninput()}function l(f){return w(this,null,function*(){return yield(yield fetch(f)).json()})}function u(f){return w(this,null,function*(){const g=new Map;for(let x=0;x<f.length;x++){const L=f[x];g.has(L)?g.set(L,g.get(L)+1):g.set(L,1)}return Array.from(g,([x,L])=>({value:x,count:L}))})}function t(f,g){return w(this,null,function*(){return f.length!==g.length&&(m="Failed to Predict Labels - "),g.map((y,x)=>{const L=f.find(S=>S.value===x),C=L?`${L.count} mm3`:"Missing";return C==="Missing"&&(m+=`${y}, `),`${y}   ${C}`})})}function i(f,g,y){return w(this,null,function*(){e();const x=yield s.volumes[0].clone();x.zeroImage(),x.hdr.scl_inter=0,x.hdr.scl_slope=1,x.img=new Uint8Array(f);const L=yield u(x.img);if(y.colormapPath){const C=yield l(y.colormapPath),S=yield t(L,C.labels);x.setColormapLabel({R:C.R,G:C.G,B:C.B,labels:S}),x.hdr.intent_code=1002}else{let C=g.atlasSelectedColorTable.toLowerCase();s.colormaps().includes(C)||(C="actc"),x.colormap=C}x.opacity=opacitySlider1.value/255,yield s.addVolume(x)})}function a(f){return w(this,null,function*(){(typeof f=="string"||f instanceof String)&&(f=function(y){const x=JSON.parse(y),L=[];for(const C in x)L[C]=x[C];return L}(f)),f=yield bo(f,s.gl),h=`:: Diagnostics can help resolve issues https://github.com/neuroneural/brainchop/issues ::
`;for(const g in f)h+=g+": "+f[g]+`
`})}function p(f="",g=-1,y="",x=[]){f!==""&&(document.getElementById("location").innerHTML=f),isNaN(g)?(memstatus.style.color="red",memstatus.innerHTML="Memory Issue"):g>=0&&(modelProgress.value=g*modelProgress.max),y!==""&&window.alert(y),Object.keys(x).length>0&&a(x)}function c(f){document.getElementById("location").innerHTML=f.string.split("   ").map(g=>`<p style="font-size: 14px;margin:0px;">${g}</p>`).join("")}const r={backColor:[.4,.4,.4,1],show3Dcrosshair:!0,onLocationChange:c};let h="",m="",d;const s=new qe(r);s.attachToCanvas(gl1),s.opts.dragMode=s.dragModes.pan,s.opts.multiplanarForceRender=!0,s.opts.yoke3Dto2DZoom=!0,s.opts.crosshairGap=11,s.setInterpolation(!0),yield s.loadVolumes([{url:"./t1_crop.nii.gz"}]);for(let f=0;f<oe.length;f++){const g=document.createElement("option");g.text=oe[f].modelName,g.value=oe[f].id.toString(),modelSelect.appendChild(g)}s.onImageLoaded=o,modelSelect.selectedIndex=-1,drawDrop.selectedIndex=-1,workerCheck.checked=yield ke();const M=new URLSearchParams(window.location.search).get("model");M&&(modelSelect.selectedIndex=Number(M),modelSelect.onchange())})}function _o(){return w(this,null,function*(){try{const e=yield(yield fetch("https://api.github.com/repos/neuroneural/brainchop")).json();document.getElementById("star-count").textContent=e.stargazers_count}catch(n){}})}(function(){return w(this,null,function*(){yield xo(),_o()})})();
