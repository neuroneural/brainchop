var x=(o,e,n)=>new Promise((i,r)=>{var s=m=>{try{t(n.next(m))}catch(d){r(d)}},l=m=>{try{t(n.throw(m))}catch(d){r(d)}},t=m=>m.done?i(m.value):Promise.resolve(m.value).then(s,l);t((n=n.apply(o,e)).next())});import{N as ye}from"./vendor-niivue-DkxzteUE.js";import{l as be,t as se,s as xe,d as W,a as ne,b as Se,c as B,e as $,m as re,r as le,f as _e,g as ie,h as ve,o as Me,z as D,i as Pe,w as oe,j as Ce,k as ce,n as Te,p as de,q as E,u as ue,v as Ae,x as Oe,y as U,A as Ee,B as ae,C as Be}from"./vendor-tf-C1mOOeJ2.js";import"./vendor-DOCzr95M.js";import"./vendor-math-CA38DMGy.js";(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))i(r);new MutationObserver(r=>{for(const s of r)if(s.type==="childList")for(const l of s.addedNodes)l.tagName==="LINK"&&l.rel==="modulepreload"&&i(l)}).observe(document,{childList:!0,subtree:!0});function n(r){const s={};return r.integrity&&(s.integrity=r.integrity),r.referrerPolicy&&(s.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?s.credentials="include":r.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function i(r){if(r.ep)return;r.ep=!0;const s=n(r);fetch(r.href,s)}})();const Ie={batchSize:1,numOfChan:1,isColorEnable:!0,isAutoColors:!0,bgLabelValue:0,drawBoundingVolume:!1,isGPU:!0,isBrainCropMaskBased:!0,showPhase1Output:!1,isPostProcessEnable:!0,isContoursViewEnable:!1,browserArrayBufferMaxZDim:30,telemetryFlag:!1,chartXaxisStepPercent:10,uiSampleName:"BC_UI_Sample",atlasSelectedColorTable:"Fire"},k=[{id:1,type:"Segmentation",path:"/models/model5_gw_ae/model.json",modelName:"âš¡ Tissue GWM (light)",colormapPath:"./models/model5_gw_ae/colormap3.json",preModelId:null,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:0,enableTranspose:!0,enableCrop:!0,cropPadding:18,autoThreshold:0,enableQuantileNorm:!1,filterOutWithPreMask:!1,enableSeqConv:!1,textureSize:0,warning:null,inferenceDelay:100,description:"Gray and white matter segmentation model. Operates on full T1 image in a single pass, but uses only 5 filters per layer. Can work on integrated graphics cards but is barely large enough to provide good accuracy. Still more accurate than the subvolume model."},{id:2,type:"Segmentation",path:"/models/model20chan3cls/model.json",modelName:"ðŸ”ª Tissue GWM (High Acc)",colormapPath:"./models/model20chan3cls/colormap.json",preModelId:null,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:0,enableTranspose:!0,enableCrop:!0,cropPadding:0,autoThreshold:.2,enableQuantileNorm:!0,filterOutWithPreMask:!1,enableSeqConv:!1,textureSize:0,warning:"This model may need dedicated graphics card.  For more info please check with Browser Resources <i class='fa fa-cogs'></i>.",inferenceDelay:100,description:"Gray and white matter segmentation model. Operates on full T1 image in a single pass but needs a dedicated graphics card to operate. Provides the best accuracy with hard cropping for better speed"},{id:3,type:"Segmentation",path:"/models/model20chan3cls/model.json",modelName:"ðŸ”ª Tissue GWM (High Acc, Low Mem)",colormapPath:"./models/model20chan3cls/colormap.json",preModelId:null,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:0,enableTranspose:!0,enableCrop:!0,cropPadding:0,autoThreshold:.2,enableQuantileNorm:!0,filterOutWithPreMask:!1,enableSeqConv:!0,textureSize:0,warning:"This model may need dedicated graphics card.  For more info please check with Browser Resources <i class='fa fa-cogs'></i>.",inferenceDelay:100,description:"Gray and white matter segmentation model. Operates on full T1 image in a single pass but needs a dedicated graphics card to operate. Provides high accuracy and fit low memory available but slower"},{id:4,type:"Atlas",path:"/models/model30chan18cls/model.json",modelName:"ðŸª“ Subcortical + GWM (High Mem, Fast)",colormapPath:"./models/model30chan18cls/colormap.json",preModelId:null,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:200,enableTranspose:!0,enableCrop:!0,cropPadding:0,autoThreshold:.2,enableQuantileNorm:!1,filterOutWithPreMask:!1,enableSeqConv:!1,textureSize:0,warning:"This model may need dedicated graphics card.  For more info please check with Browser Resources <i class='fa fa-cogs'></i>.",inferenceDelay:100,description:"Parcellation of the brain into 17 regions: gray and white matter plus subcortical areas. This is a robust model able to handle range of data quality, including varying saturation, and even clinical scans. It may work on infant brains, but your mileage may vary."},{id:5,type:"Atlas",path:"/models/model30chan18cls/model.json",modelName:"ðŸª“ Subcortical + GWM (Low Mem, Slow)",colormapPath:"./models/model30chan18cls/colormap.json",preModelId:null,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:200,enableTranspose:!0,enableCrop:!0,cropPadding:0,autoThreshold:.2,enableQuantileNorm:!1,filterOutWithPreMask:!1,enableSeqConv:!0,textureSize:0,warning:"This model may need dedicated graphics card.  For more info please check with Browser Resources <i class='fa fa-cogs'></i>.",inferenceDelay:100,description:"Parcellation of the brain into 17 regions: gray and white matter plus subcortical areas. This is a robust model able to handle range of data quality, including varying saturation, and even clinical scans. It may work on infant brains, but your mileage may vary."},{id:6,type:"Atlas",path:"/models/model18cls/model.json",modelName:"ðŸª“ Subcortical + GWM (Low Mem, Faster)",colormapPath:"./models/model18cls/colormap.json",preModelId:null,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:200,enableTranspose:!0,enableCrop:!0,cropPadding:0,autoThreshold:.2,enableQuantileNorm:!1,filterOutWithPreMask:!1,enableSeqConv:!0,textureSize:0,warning:"This model may need dedicated graphics card.  For more info please check with Browser Resources <i class='fa fa-cogs'></i>.",inferenceDelay:100,description:"Parcellation of the brain into 17 regions: gray and white matter plus subcortical areas. This is a robust model able to handle range of data quality, including varying saturation, and even clinical scans. It may work on infant brains, but your mileage may vary."},{id:7,type:"Atlas",path:"/models/model30chan18cls/model.json",modelName:"ðŸ”ªðŸª“ Subcortical + GWM (Failsafe, Less Acc)",colormapPath:"./models/model30chan18cls/colormap.json",preModelId:1,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:200,enableTranspose:!0,enableCrop:!0,cropPadding:0,autoThreshold:0,enableQuantileNorm:!1,filterOutWithPreMask:!1,enableSeqConv:!1,textureSize:0,warning:"This model may need dedicated graphics card.  For more info please check with Browser Resources <i class='fa fa-cogs'></i>.",inferenceDelay:100,description:"Parcellation of the brain into 17 regions: gray and white matter plus subcortical areas. This is not a robust model, it may work on low data quality, including varying saturation, and even clinical scans. It may work also on infant brains, but your mileage may vary."},{id:8,type:"Atlas",path:"/models/model30chan50cls/model.json",modelName:"ðŸ”ª Aparc+Aseg 50 (High Mem, Fast)",colormapPath:"./models/model30chan50cls/colormap.json",preModelId:1,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:200,enableTranspose:!0,enableCrop:!0,cropPadding:0,autoThreshold:0,enableQuantileNorm:!0,filterOutWithPreMask:!1,enableSeqConv:!1,textureSize:0,warning:"This model may need dedicated graphics card.  For more info please check with Browser Resources <i class='fa fa-cogs'></i>.",inferenceDelay:100,description:"This is a 50-class model, that segments the brain into the Aparc+Aseg Freesurfer Atlas but one where cortical homologues are merged into a single class."},{id:9,type:"Atlas",path:"/models/model30chan50cls/model.json",modelName:"ðŸ”ª Aparc+Aseg 50 (Low Mem, Slow)",colormapPath:"./models/model30chan50cls/colormap.json",preModelId:1,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:200,enableTranspose:!0,enableCrop:!0,cropPadding:0,autoThreshold:0,enableQuantileNorm:!0,filterOutWithPreMask:!1,enableSeqConv:!0,textureSize:0,warning:"This model may need dedicated graphics card.  For more info please check with Browser Resources <i class='fa fa-cogs'></i>.",inferenceDelay:100,description:"This is a 50-class model, that segments the brain into the Aparc+Aseg Freesurfer Atlas but one where cortical homologues are merged into a single class. The model use sequential convolution for inference to overcome browser memory limitations but leads to longer computation time."},{id:10,type:"Brain_Extraction",path:"/models/model5_gw_ae/model.json",modelName:"âš¡ Extract the Brain (FAST)",preModelId:null,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:0,enableTranspose:!0,enableCrop:!0,cropPadding:18,autoThreshold:0,enableQuantileNorm:!1,filterOutWithPreMask:!1,enableSeqConv:!1,textureSize:0,warning:null,inferenceDelay:100,description:"Extract the brain fast model operates on full T1 image in a single pass, but uses only 5 filters per layer. Can work on integrated graphics cards but is barely large enough to provide good accuracy. Still more accurate than the failsafe version."},{id:11,type:"Brain_Extraction",path:"/models/model11_gw_ae/model.json",modelName:"ðŸ”ª Extract the Brain (High Acc, Slow)",preModelId:null,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:0,enableTranspose:!0,enableCrop:!0,cropPadding:0,autoThreshold:0,enableQuantileNorm:!1,filterOutWithPreMask:!1,enableSeqConv:!0,textureSize:0,warning:"This model may need dedicated graphics card.  For more info please check with Browser Resources <i class='fa fa-cogs'></i>.",inferenceDelay:100,description:"Extract the brain high accuracy model operates on full T1 image in a single pass, but uses only 11 filters per layer. Can work on dedicated graphics cards. Still more accurate than the fast version."},{id:12,type:"Brain_Masking",path:"/models/model5_gw_ae/model.json",modelName:"âš¡ Brain Mask (FAST)",colormapPath:"./models/model5_gw_ae/colormap.json",preModelId:null,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:0,enableTranspose:!0,enableCrop:!0,cropPadding:17,autoThreshold:0,enableQuantileNorm:!1,filterOutWithPreMask:!1,enableSeqConv:!1,textureSize:0,warning:null,inferenceDelay:100,description:"This fast masking model operates on full T1 image in a single pass, but uses only 5 filters per layer. Can work on integrated graphics cards but is barely large enough to provide good accuracy. Still more accurate than failsafe version."},{id:13,type:"Brain_Masking",path:"/models/model11_gw_ae/model.json",modelName:"ðŸ”ª Brain Mask (High Acc, Low Mem)",preModelId:null,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:0,enableTranspose:!0,enableCrop:!0,cropPadding:0,autoThreshold:0,enableQuantileNorm:!0,filterOutWithPreMask:!1,enableSeqConv:!0,textureSize:0,warning:"This model may need dedicated graphics card.  For more info please check with Browser Resources <i class='fa fa-cogs'></i>.",inferenceDelay:100,description:"This masking model operates on full T1 image in a single pass, but uses 11 filters per layer. Can work on dedicated graphics cards. Still more accurate than fast version."},{id:14,type:"Atlas",path:"/models/model21_104class/model.json",modelName:"ðŸ”ª Aparc+Aseg 104 (High Mem, Fast)",colormapPath:"./models/model21_104class/colormap.json",preModelId:1,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:200,enableTranspose:!0,enableCrop:!0,cropPadding:0,autoThreshold:0,enableQuantileNorm:!1,filterOutWithPreMask:!1,enableSeqConv:!1,textureSize:0,warning:"This model may need dedicated graphics card.  For more info please check with Browser Resources <i class='fa fa-cogs'></i>.",inferenceDelay:100,description:"FreeSurfer aparc+aseg atlas 104 parcellate brain areas into 104 regions. It contains a combination of the Desikan-Killiany atlas for cortical area and also segmentation of subcortical regions."},{id:15,type:"Atlas",path:"/models/model21_104class/model.json",modelName:"ðŸ”ª Aparc+Aseg 104 (Low Mem, Slow)",colormapPath:"./models/model21_104class/colormap.json",preModelId:null,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:200,enableTranspose:!0,enableCrop:!0,cropPadding:0,autoThreshold:0,enableQuantileNorm:!1,filterOutWithPreMask:!1,enableSeqConv:!0,textureSize:0,warning:"This model may need dedicated graphics card.  For more info please check with Browser Resources <i class='fa fa-cogs'></i>.",inferenceDelay:100,description:"FreeSurfer aparc+aseg atlas 104 parcellate brain areas into 104 regions. It contains a combination of the Desikan-Killiany atlas for cortical area and also segmentation of subcortical regions. The model use sequential convolution for inference to overcome browser memory limitations but leads to longer computation time. "},{id:16,type:"Brain_Extraction",path:"/models/mindgrab/model.json",modelName:"ðŸ§ ðŸª“ omnimodal Skull Strip (High Mem, Fast)",preModelId:null,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:0,enableTranspose:!0,enableCrop:!0,cropPadding:20,autoThreshold:.5,enableQuantileNorm:!1,filterOutWithPreMask:!1,enableSeqConv:!1,textureSize:0,warning:"This model may need dedicated graphics card.  For more info please check with Browser Resources <i class='fa fa-cogs'></i>.",inferenceDelay:100,description:"The omnimodal skull stripping model delivers high-accuracy brain extraction in seconds, supporting multiple imaging modalities including T1, T2, FLAIR, DWI, EPI, MRA, PDw, CT, and PET without a need for tuning. It runs in a single pass with only 15 filters per layer, and is offered in high-memory/fast and low-memory/slow configurations. Use it today to improve and accelerate your brain extraction!"},{id:17,type:"Brain_Extraction",path:"/models/mindgrab/model.json",modelName:"ðŸ§ ðŸª“ omnimodal Skull Strip (Low Mem, Slow)",preModelId:null,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:0,enableTranspose:!0,enableCrop:!0,cropPadding:20,autoThreshold:.5,enableQuantileNorm:!1,filterOutWithPreMask:!1,enableSeqConv:!0,textureSize:0,warning:"This model may need dedicated graphics card.  For more info please check with Browser Resources <i class='fa fa-cogs'></i>.",inferenceDelay:100,description:"The omnimodal skull stripping model delivers high-accuracy brain extraction in seconds, supporting multiple imaging modalities including T1, T2, FLAIR, DWI, EPI, MRA, PDw, CT, and PET without a need for tuning. It runs in a single pass with only 15 filters per layer, and is offered in high-memory/fast and low-memory/slow configurations. Use it today to improve and accelerate your brain extraction!"}];class Le{idx(e,n,i,r){return i*r[0]*r[1]+n*r[0]+e}check_previous_slice(e,n,i,r,s,l,t,m,d,u){let h=0;if(!s)return 0;const f=e[this.idx(i,r,s,l)];if(t>=6){const c=this.idx(i,r,s-1,l);f===e[c]&&(d[h++]=n[c])}if(t>=18){if(i){const c=this.idx(i-1,r,s-1,l);f===e[c]&&(d[h++]=n[c])}if(r){const c=this.idx(i,r-1,s-1,l);f===e[c]&&(d[h++]=n[c])}if(i<l[0]-1){const c=this.idx(i+1,r,s-1,l);f===e[c]&&(d[h++]=n[c])}if(r<l[1]-1){const c=this.idx(i,r+1,s-1,l);f===e[c]&&(d[h++]=n[c])}}if(t===26){if(i&&r){const c=this.idx(i-1,r-1,s-1,l);f===e[c]&&(d[h++]=n[c])}if(i<l[0]-1&&r){const c=this.idx(i+1,r-1,s-1,l);f===e[c]&&(d[h++]=n[c])}if(i&&r<l[1]-1){const c=this.idx(i-1,r+1,s-1,l);f===e[c]&&(d[h++]=n[c])}if(i<l[0]-1&&r<l[1]-1){const c=this.idx(i+1,r+1,s-1,l);f===e[c]&&(d[h++]=n[c])}}return h?(this.fill_tratab(m,d,h,u),d[0]):0}do_initial_labelling(e,n,i){const r=new Uint32Array(32),s=new Uint32Array(32);let l=1;const t=8192;let m=t,d=new Uint32Array(m).fill(0);const u=new Uint32Array(n[0]*n[1]*n[2]).fill(0),h=new Uint32Array(27);for(let f=0;f<n[2];f++)for(let c=0;c<n[1];c++)for(let a=0;a<n[0];a++){let b=0;const _=e[this.idx(a,c,f,n)];if(_!==0){if(h[0]=this.check_previous_slice(e,u,a,c,f,n,i,d,r,s),h[0]&&(b+=1),i>=6){if(a){const p=this.idx(a-1,c,f,n);_===e[p]&&(h[b++]=u[p])}if(c){const p=this.idx(a,c-1,f,n);_===e[p]&&(h[b++]=u[p])}}if(i>=18){if(c&&a){const p=this.idx(a-1,c-1,f,n);_===e[p]&&(h[b++]=u[p])}if(c&&a<n[0]-1){const p=this.idx(a+1,c-1,f,n);_===e[p]&&(h[b++]=u[p])}}if(b)u[this.idx(a,c,f,n)]=h[0],this.fill_tratab(d,h,b,s);else{if(u[this.idx(a,c,f,n)]=l,l>=m){m+=t;const p=new Uint32Array(m);p.set(d),d=p}d[l-1]=l,l++}}}for(let f=0;f<l-1;f++){let c=f;for(;d[c]!==c+1;)c=d[c]-1;d[f]=c+1}return[l-1,d,u]}fill_tratab(e,n,i,r){let l=2147483647;for(let t=0;t<i;t++){let m=n[t];for(;e[m-1]!==m;)m=e[m-1];r[t]=m,l=Math.min(l,m)}for(let t=0;t<i;t++)e[r[t]-1]=l}translate_labels(e,n,i,r){const s=n[0]*n[1]*n[2];let l=0;const t=new Uint32Array(s).fill(0);for(let u=0;u<r;u++)l=Math.max(l,i[u]);const m=new Uint32Array(l).fill(0);let d=0;for(let u=0;u<s;u++)e[u]&&(m[i[e[u]-1]-1]||(d+=1,m[i[e[u]-1]-1]=d),t[u]=m[i[e[u]-1]-1]);return[d,t]}largest_original_cluster_labels(e,n,i){const r=e.length,s=new Uint32Array(n+1).fill(0),l=new Uint32Array(n+1).fill(0);for(let d=0;d<r;d++){const u=e[d],h=i[d];s[h]=u,l[h]++}let t=0;for(let d=0;d<n+1;d++){const u=s[d];t=Math.max(t,u);for(let h=0;h<n+1;h++)h!==d&&u===s[h]&&(l[d]<l[h]||l[d]===l[h]&&d<h)&&(s[d]=0)}const m=new Uint32Array(r).fill(0);for(let d=0;d<r;d++)m[d]=s[i[d]];return[t,m]}bwlabel(e,n,i=26,r=!1,s=!1){const l=Date.now(),t=n[0]*n[1]*n[2],m=new Uint32Array(t).fill(0);if(![6,18,26].includes(i))return[0,m];if(n[0]<2||n[1]<2||n[2]<1)return[0,m];if(r)for(let a=0;a<t;a++)e[a]!==0&&(m[a]=1);else m.set(e);let[d,u,h]=this.do_initial_labelling(m,n,i);u===void 0&&(u=new Uint32Array(0));const[f,c]=this.translate_labels(h,n,u,d);if(s){const[a,b]=this.largest_original_cluster_labels(m,f,c);return[a,b]}return[f,c]}}function Ne(o,e){return x(this,null,function*(){const n=o.max(),i=n.mul(e),r=yield i.data();return n.dispose(),i.dispose(),B(()=>o.clone().greater(r[0]))})}function Fe(o,e=.01,n=.99){return x(this,null,function*(){const i=o.flatten(),r=yield i.array();r.sort((c,a)=>c-a);const s=Se(r),l=s.shape[0],t=Math.floor(l*e),m=Math.ceil(l*n)-1,d=s.slice(t,1),u=s.slice(m,1),h=(yield d.array())[0],f=(yield u.array())[0];return i.dispose(),s.dispose(),d.dispose(),u.dispose(),{qmin:h,qmax:f}})}function ke(o,e,n,i,r,s,l){return x(this,null,function*(){const t=o.shape[4],m=e.shape[4];let d=null;for(let u=0;u<m;u++){const h=Math.ceil(t/l);let f=null;for(let a=0;a<h;a++){const b=a*l,_=Math.min((a+1)*l,t);if(b<t){const p=B(()=>{const g=o.slice([0,0,0,0,b],[-1,-1,-1,-1,_-b]),w=e.slice([0,0,0,b,u],[-1,-1,-1,_-b,1]);return $(g,w,i,r,"NDHWC",s)});if(f===null)f=p;else{const g=f.add(p);f.dispose(),p.dispose(),f=g}}}let c;if(n){const a=n.slice([u],[1]);c=f.add(a),f.dispose(),a.dispose()}else c=f;if(d==null)d=c;else{const a=yield de([d,c],4);c.dispose(),d.dispose(),d=a}}return d})}function Re(o,e=1e-5){return B(()=>{const{mean:n,variance:i}=re(o,[1,2,3],!0),r=le(i.add(e));return o.sub(n).mul(r)})}function We(o,e,n,i,r,s,l){return x(this,null,function*(){const t=o.shape[4],m=e.shape[4];let d=null;for(let u=0;u<m;u++){const h=Math.ceil(t/l);let f=null;for(let b=0;b<h;b++){const _=b*l,p=Math.min((b+1)*l,t);if(_<t){const g=B(()=>{const w=o.slice([0,0,0,0,_],[-1,-1,-1,-1,p-_]),y=e.slice([0,0,0,_,u],[-1,-1,-1,p-_,1]);return $(w,y,i,r,"NDHWC",s)});if(f===null)f=g;else{const w=f.add(g);f.dispose(),g.dispose(),f=w}}}let c;if(n){const b=n.slice([u],[1]);c=f.add(b),f.dispose(),b.dispose()}else c=f;const a=Re(c);if(c.dispose(),d===null)d=a;else{const b=yield de([d,a],4);a.dispose(),d.dispose(),d=b}}return d})}function Ve(o,e=1e-5){return B(()=>{const{mean:n,variance:i}=re(o,[1,2,3],!0),r=le(_e(i,e));return ie(ve(o,n),r)})}function Q(o,e=0){return x(this,null,function*(){let n=[];e===0?n=yield o.max(2).max(1).arraySync():e===1?n=yield o.max(2).max(0).arraySync():n=yield o.max(1).max(0).arraySync();let i=n.length,r=0;for(let s=0;s<n.length;s++)if(n[s]>0){i=s;break}for(let s=n.length-1;s>=0;s--)if(n[s]>0){r=s;break}return[i,r]})}function qe(o){return x(this,null,function*(){const[e,n]=yield Q(o,0),[i,r]=yield Q(o,1),[s,l]=yield Q(o,2);return[e,n,i,r,s,l]})}function Ge(o,e,n,i,r,s,l,t,m=!0){return x(this,null,function*(){o[0].dtype!=="int32"&&l("",-1,"generateBrainMask assumes int32"),r.preModelPostProcess&&l("",-1,"generateBrainMask assumes BWLabeler instead of preModelPostProcess");const d=o.length,u=o[0].size,h=d*u,f=new Int32Array(h);let c=0;for(let a=0;a<d;a++)f.set(o[a].dataSync(),c),c+=u;for(let a=0;a<h;a++)f[a]=f[a]!==0?1:0;return(m||s.showPhase1Output)&&(t(f,s,r),l("Segmentation finished",0)),se(f,[e,n,i])})}function ze(o,e,n){return x(this,null,function*(){const i=e.dims[1],r=e.dims[2];let s;if(e.datatypeCode===2)s=new Uint8Array(n);else if(e.datatypeCode===4)s=new Int16Array(n);else if(e.datatypeCode===8)s=new Int32Array(n);else if(e.datatypeCode===16)s=new Float32Array(n);else if(e.datatypeCode===64)s=new Float64Array(n);else if(e.datatypeCode===256)s=new Int8Array(n);else if(e.datatypeCode===512)s=new Uint16Array(n);else if(e.datatypeCode===768)s=new Uint32Array(n);else return;const l=[];let t=0;for(let d=0;d<o;d++){const u=new Array(r*i);let h=0;for(let f=0;f<r;f++)for(let c=0;c<i;c++){const a=s[t++];u[h++]=a&255}l.push(se(u,[r,i]))}const m=xe(l);return W(l),m})}function je(o){return x(this,null,function*(){return o.layers.length})}function Ue(o){return x(this,null,function*(){let e=0;for(let n=0;n<o.layers.length;n++)e+=o.layers[n].countParams();return e})}function H(o){return x(this,null,function*(){for(let e=0;e<o.layers.length;e++)if(o.layersByDepth[e][0].dataFormat)return o.layersByDepth[e][0].dataFormat==="channelsLast"})}function pe(o){return x(this,null,function*(){return yield be(o)})}function fe(o){return x(this,null,function*(){const e=o.max(),n=o.min();return yield o.sub(n).div(e.sub(n))})}function Qe(o,e,n){const l=o.shape[4],t=Math.ceil(l/n);let m=null;for(let d=0;d<t;d++){const u=d*n,f=Math.min((d+1)*n,l)-u,c=B(()=>o.slice([0,0,0,0,u],[-1,-1,-1,-1,f])),a=B(()=>e.slice([0,0,0,u,0],[-1,-1,-1,f,-1])),b=$(c,a,1,0,"NDHWC",1);c.dispose(),a.dispose();const _=ce(b);if(b.dispose(),m===null)m=_;else{const p=m.add(_);m.dispose(),m!==_&&_.dispose(),m=p}B(()=>{Te(D([1,1]),D([1,1]))})}return m}function me(o,e=.05,n=.95){return x(this,null,function*(){const{qmin:i,qmax:r}=yield Fe(o,e,n),s=ne(i),l=ne(r),t=o.sub(s).div(l.sub(s));return s.dispose(),l.dispose(),t})}class De{constructor(e,n,i,r,s=!0){this.model=e,this.outChannels=e.outputLayers[0].kernel.shape[4],this.chunkSize=n,this.isChannelLast=i,this.callbackUI=r,this.isWebWorker=s}apply(e){return x(this,null,function*(){const n=performance.now(),i=this.model.layers[this.model.layers.length-1],r=i.getWeights()[0],s=i.getWeights()[1],l=this.isChannelLast?e.shape.slice(1,-1):e.shape.slice(2);let t=yield ie(Me(l),-1e4),m=yield D(l);const d=3,u=Math.ceil(this.outChannels/d);for(let c=0;c<u;c++){const a=c*d,b=Math.min((c+1)*d,this.outChannels),[_,p]=yield B(()=>{let g=t,w=m;for(let y=a;y<b;y++){const P=r.slice([0,0,0,0,y],[-1,-1,-1,-1,1]),v=s.slice([y],[1]),S=Qe(e,P,Math.min(this.chunkSize,this.outChannels)).add(v),A=Pe(S,g);g=oe(A,S,g),w=oe(A,Ce(w.shape,y),w)}return[g,w]});W([t,m]),t=_,m=p,this.callbackUI(`Processing chunk ${c+1}/${u}`,(c+1)/u),this.isWebWorker||(yield new Promise(g=>setTimeout(g,0)))}const h=m.clone();W([t,m]);const f=performance.now();return h})}}function $e(o,e,n,i){return x(this,null,function*(){const r=yield o.data(),s=o.shape;if(i.isPostProcessEnable){const l=performance.now(),t=new Le,[m,d]=t.bwlabel(r,s,26,!0,!0);for(let h=0;h<r.length;h++)r[h]*=d[h];const u=((performance.now()-l)/1e3).toFixed(4)}switch(n.type){case"Brain_Masking":{const l=new Uint8Array(r.length);for(let t=0;t<r.length;t++)l[t]=r[t]!==0?1:0;return l}case"Brain_Extraction":{const l=new Uint8Array(r.length);for(let t=0;t<r.length;t++){const m=r[t]!==0?1:0;l[t]=e[t]*m}return l}default:return new Uint8Array(r)}})}function He(o,e,n){return x(this,null,function*(){const[i,r,s,l,t,m]=yield qe(e),d=r-i+1,u=l-s+1,h=m-t+1,f=(y,P,v,S)=>{const A=Math.min(y,S),T=Math.min(255-P,S),L=Math.max(0,y-A),R=Math.min(255,P+T);return[L,R]},[c,a]=f(i,r,d,n),[b,_]=f(s,l,u,n),[p,g]=f(t,m,h,n);return{cropped:o.slice([c,b,p],[a-c+1,_-b+1,g-p+1]),corner:[c,b,p]}})}function Xe(o,e){return x(this,null,function*(){const[n,i,r]=e,[s,l,t]=o.shape,m=[[n,Math.max(0,256-s-n)],[i,Math.max(0,256-l-i)],[r,Math.max(0,256-t-r)]];return o.pad(m)})}function te(o,e,n,i,r,s,l,t,m){return x(this,null,function*(){const d=performance.now();e.enableQuantileNorm?i=yield me(i):i=yield fe(i);let u;if(r==null){const M=e.autoThreshold;M>0&&M<=1?u=yield Ne(i,M):u=yield i.greater([0]).asType("bool")}else u=yield r.greater([0]).asType("bool");const h=e.cropPadding;let{cropped:f,corner:c}=yield He(i,u,h);i.dispose(),u.dispose(),e.enableTranspose&&(f=f.transpose());const a=yield n,b=a.layers.length,_=H(a);let p;_?(a.layers[0].batchInputShape[1]=f.shape[0],a.layers[0].batchInputShape[2]=f.shape[1],a.layers[0].batchInputShape[3]=f.shape[2],p=[o.batchSize,a.layers[0].batchInputShape[1],a.layers[0].batchInputShape[2],a.layers[0].batchInputShape[3],o.numOfChan]):(a.layers[0].batchInputShape[2]=f.shape[0],a.layers[0].batchInputShape[3]=f.shape[1],a.layers[0].batchInputShape[4]=f.shape[2],p=[o.batchSize,o.numOfChan,a.layers[0].batchInputShape[2],a.layers[0].batchInputShape[3],a.layers[0].batchInputShape[4]]);let g=f.reshape(p),w=1;const y=performance.now(),P=/^((?!chrome|android).)*safari/i.test(navigator.userAgent),v=navigator.userAgent.toLowerCase().indexOf("firefox")>-1;let S=P||v?10:15;e.enableSeqConv&&(S=1);const A=e.enableSeqConv?b-2:b-1;for(;w<=A;){try{let M;e.enableSeqConv&&a.layers[w].activation.getClassName()==="linear"?M=yield(a.layers[w].name.endsWith("_gn")?We:ke)(g,a.layers[w].getWeights()[0],a.layers[w].getWeights()[1],a.layers[w].strides,a.layers[w].padding,a.layers[w].dilationRate,3):M=B(()=>{let O=a.layers[w].apply(g);return a.layers[w].name.endsWith("_gn")&&(O=Ve(O)),O}),g.dispose(),g=M}catch(M){return t(M.message,-1,M.message),E().endScope(),E().disposeVariables(),s.Inference_t=1/0,s.Postprocess_t=1/0,s.Status="Fail",s.Error_Type=M.message,s.Extra_Err_Info="Failed while model layer "+w+" apply",t("",-1,"",s),0}if(w%S===0){t("Layer "+w.toString(),(w+1)/b);const M=g.slice([0,0,0,0,0],[1,1,1,1,1]);yield M.data(),M.dispose()}else t("Layer "+w.toString(),(w+1)/b);w++}let T;e.enableSeqConv?(T=yield new De(a,10,_,t).apply(g),g.dispose()):(T=B(()=>{const O=ue(g,_?-1:1);return ce(O)}),g.dispose());const L=((performance.now()-y)/1e3).toFixed(4);e.enableTranspose&&(T=T.transpose());const R=performance.now();T=yield Xe(T,c);const K=((performance.now()-R)/1e3).toFixed(4),C=performance.now(),G=yield $e(T,m,e,o),I=((performance.now()-C)/1e3).toFixed(4);T.dispose(),E().disposeVariables();const q=((performance.now()-d)/1e3).toFixed(4);return s.Inference_t=L,s.Postprocess_t=I,s.Status="OK",t("Segmentation finished",0),t("",-1,"",s),l(G,o,e),0})}function Ke(o,e,n,i,r,s,l,t,m,d,u,h){return x(this,null,function*(){if(t.No_SubVolumes=1,l.preModelId){const f=yield pe(m.rootURL+k[l.preModelId-1].path),c=k[l.preModelId-1].enableTranspose,a=k[l.preModelId-1].enableQuantileNorm;let b=null;a?b=yield me(e):b=yield fe(e),c&&(b=yield b.transpose()),t.Brainchop_Ver="PreModel_FV";const _=yield f;try{const p=performance.now(),g=_,w=g.layers[0].batchInputShape;if(w.length!==5){const M="The pre-model input shape must be 5D ";return u(M,-1,M),0}const y=H(g),P=m.batchSize,v=m.numOfChan;let S,A,T,L;if(y){if(isNaN(w[4])||w[4]!==1){const M="The number of channels for pre-model input shape must be 1";return u(M,-1,M),0}S=w[1],A=w[2],T=w[3],L=[P,S,A,T,v]}else{if(isNaN(w[1])||w[1]!==1){const M="The number of channels for pre-model input shape must be 1";return u(M,-1,M),0}S=w[2],A=w[3],T=w[4],L=[P,v,S,A,T]}t.Input_Shape=JSON.stringify(L),t.Output_Shape=JSON.stringify(g.output.shape),t.Channel_Last=y,t.Model_Param=yield Ue(g),t.Model_Layers=yield je(g);let R=0;const K=k[l.preModelId-1].inferenceDelay;let C=1;const G=_.layers.length,I=[];I[0]=b.reshape(L),W(b);const q=window.setInterval(function(){return x(this,null,function*(){try{I[C]=yield _.layers[C].apply(I[C-1])}catch(M){const O="Your graphics card (e.g. Intel) may not be compatible with WebGL. "+M.message;return u(O,-1,O),window.clearInterval(q),E().endScope(),E().disposeVariables(),t.Inference_t=1/0,t.Postprocess_t=1/0,t.Status="Fail",t.Error_Type=M.message,t.Extra_Err_Info="PreModel Failed while model layer "+C+" apply",u("",-1,"",t),0}if(_.layers[C].dispose(),I[C-1].dispose(),u("Layer "+C.toString(),(C+1)/G),ae().unreliable){const M="unreliable reasons :"+ae().reasons;u(M,NaN,M)}if(C===G-1){window.clearInterval(q);const M=y?-1:1,O=y?I[C].shape[4]:I[C].shape[1];let V;try{V=yield ue(I[C],M)}catch(N){if(M===-1)try{const F=performance.now();window.alert("tensor2LightBuffer() is not dead code?"),window.alert("argMaxLarge() is not dead code?")}catch(F){const ee="argMax buffer couldn't be created due to limited memory resources.";return u(ee,-1,ee),V.dispose(),window.clearInterval(q),E().endScope(),E().disposeVariables(),t.Inference_t=1/0,t.Postprocess_t=1/0,t.Status="Fail",t.Error_Type=F.message,t.Extra_Err_Info="preModel prediction_argmax from argMaxLarge failed",u("",-1,"",t),0}else{const F="argMax buffer couldn't be created due to limited memory resources.";return u(F,-1,F),V.dispose(),window.clearInterval(q),E().endScope(),E().disposeVariables(),t.Inference_t=1/0,t.Postprocess_t=1/0,t.Status="Fail",t.Error_Type=N.message,t.Extra_Err_Info="preModel prediction_argmax from argMaxLarge not support yet channel first",u("",-1,"",t),0}}const Z=((performance.now()-p)/1e3).toFixed(4);W(I[C]);const Y=yield V.max().dataSync()[0];R<Y&&(R=Y);const J=R+1;t.Actual_Labels=J,t.Expect_Labels=O,t.NumLabels_Match=J===O;let z=yield V.reshape([n,i,r]);W(V),c&&(z=z.transpose());const ge=performance.now();let j;try{const N=yield Be(z);j=yield Ge(N,n,i,r,l,m,u,d,!1),yield W(z)}catch(N){E().endScope(),E().disposeVariables();const F="Failed while generating pre-model output due to limited browser memory available";return u(F,-1,F),t.Inference_t=Z,t.Postprocess_t=1/0,t.Status="Fail",t.Error_Type=N.message,t.Extra_Err_Info="Pre-model failed while generating output",u("",-1,"",t),0}const we=((performance.now()-ge)/1e3).toFixed(4);if(t.Inference_t=Z,t.Postprocess_t=we,t.Status="OK",u("",-1,"",t),j==null){const N="slice_3d_mask failed ...";return u(N,-1,N),0}else s?te(m,l,o,e,j,t,d,u,h):window.alert("inferenceSubVolumes() is not dead code?")}C++})},K)}catch(p){u(p.message,-1,p.message)}}else s?te(m,l,o,e,null,t,d,u,h):window.alert("inferenceSubVolumes() is not dead code?")})}function Ze(o=!0){return x(this,null,function*(){yield Oe(),U().set("DEBUG",!1),U().set("WEBGL_FORCE_F16_TEXTURES",o),U().set("WEBGL_DELETE_TEXTURE_THRESHOLD",-1),yield Ee()})}function Ye(o,e,n,i,r,s){return x(this,null,function*(){const l=[];l.startTime=Date.now(),s("Segmentation started",0),performance.now();const t=o.batchSize,m=o.numOfChan;if(isNaN(t)||t!==1){const S="The batch Size for input shape must be 1";return s(S,-1,S),0}if(isNaN(m)||m!==1){const S="The number of channels for input shape must be 1";return s(S,-1,S),0}E().startScope();const d=yield pe(o.rootURL+e.path);yield Ze(!0),l.TF_Backend=Ae();const u=d;let h=[];if(h=u.layers[0].batchInputShape,h.length!==5){const S="The model input shape must be 5D";return s(S,-1,S),0}let f,c,a;const b=n.dims[1],_=n.dims[2],p=n.dims[3];if(yield H(u)){if(isNaN(h[4])||h[4]!==1){const S="The number of channels for input shape must be 1";return s(S,-1,S),0}f=h[1],c=h[2],a=h[3]}else{if(isNaN(h[1])||h[1]!==1){const S="The number of channels for input shape must be 1";return s(S,-1,S),0}f=h[2],c=h[3],a=h[4]}let w;f===256&&c===256&&a===256?w=!0:w=!1,l.isModelFullVol=w;let y=yield ze(p,n,i);const P=e.enableTranspose,v=e.enableCrop;w&&(v?yield Ke(d,y,p,_,b,w,e,l,o,r,s,i):(P&&(y=y.transpose()),e.enableSeqConv?window.alert("inferenceFullVolumeSeqCovLayer() is not dead code?"):window.alert("inferenceFullVolume() is not dead code?")))})}function X(){return x(this,null,function*(){return navigator.userAgent.indexOf("OPR/")>-1?"Opera":navigator.userAgent.indexOf("Edg/")>-1?"Edge":navigator.userAgent.indexOf("Falkon/")>-1?"Falkon":navigator.userAgent.indexOf("Chrome/")>-1?"Chrome":navigator.userAgent.indexOf("Firefox/")>-1?"Firefox":navigator.userAgent.indexOf("Safari/")>-1?"Safari":navigator.userAgent.indexOf("MSIE/")>-1||navigator.userAgent.indexOf("rv:")>-1?"IExplorer":"Unknown"})}function Je(){return x(this,null,function*(){return navigator.userAgent.indexOf("OPR/")>-1?parseInt(navigator.userAgent.split("OPR/")[1]):navigator.userAgent.indexOf("Edg/")>-1?parseInt(navigator.userAgent.split("Edg/")[1]):navigator.userAgent.indexOf("Falkon/")>-1?parseInt(navigator.userAgent.split("Falkon/")[1]):navigator.userAgent.indexOf("Chrome/")>-1?parseInt(navigator.userAgent.split("Chrome/")[1]):navigator.userAgent.indexOf("Firefox/")>-1?parseInt(navigator.userAgent.split("Firefox/")[1]):navigator.userAgent.indexOf("Safari/")>-1?parseInt(navigator.userAgent.split("Safari/")[1]):navigator.userAgent.indexOf("MSIE/")>-1||navigator.userAgent.indexOf("rv:")>-1?parseInt(navigator.userAgent.split("MSIE/")[1]):1/0})}function en(){return x(this,null,function*(){return navigator.userAgent.indexOf("Win")>-1?"Windows":navigator.userAgent.indexOf("Mac")>-1?"MacOS":navigator.userAgent.indexOf("Linux")>-1?"Linux":navigator.userAgent.indexOf("UNIX")>-1?"UNIX":"Unknown"})}function nn(o){return x(this,null,function*(){return!!o})}function on(o){return x(this,null,function*(){let e;if(o&&(e=o.getExtension("WEBGL_debug_renderer_info"),e)){const n=o.getParameter(e.UNMASKED_VENDOR_WEBGL);return n.indexOf("(")>-1&&n.indexOf(")")>-1?n.substring(n.indexOf("(")+1,n.indexOf(")")):n}return null})}function an(o){return x(this,null,function*(){if(o){const e=o.getExtension("WEBGL_debug_renderer_info");return e?o.getParameter(e.UNMASKED_VENDOR_WEBGL):null}else return null})}function tn(o){return x(this,null,function*(){if(o){if(X()==="Firefox")return o.getParameter(o.RENDERER);const e=o.getExtension("WEBGL_debug_renderer_info");return e?o.getParameter(e.UNMASKED_RENDERER_WEBGL):null}else return null})}function sn(o){return x(this,null,function*(){let e;if(o){if(X()==="Firefox")return o.getParameter(o.RENDERER);if(e=o.getExtension("WEBGL_debug_renderer_info"),e){let n=o.getParameter(e.UNMASKED_RENDERER_WEBGL);return n.indexOf("(")>-1&&n.indexOf(")")>-1&&n.indexOf("(R)")===-1&&(n=n.substring(n.indexOf("(")+1,n.indexOf(")")),n.split(",").length===3)?n.split(",")[1].trim():n}}return null})}function rn(){return x(this,null,function*(){return navigator.hardwareConcurrency})}function he(){return x(this,null,function*(){return/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)})}function ln(o,e=null){return x(this,null,function*(){const n=new Date;if(o.isModelFullVol?o.Brainchop_Ver="FullVolume":o.Brainchop_Ver="SubVolumes",o.Total_t=(Date.now()-o.startTime)/1e3,delete o.startTime,o.Date=parseInt(n.getMonth()+1)+"/"+n.getDate()+"/"+n.getFullYear(),o.Browser=yield X(),o.Browser_Ver=yield Je(),o.OS=yield en(),o.WebGL2=yield nn(e),o.GPU_Vendor=yield on(e),o.GPU_Card=yield sn(e),o.GPU_Vendor_Full=yield an(e),o.GPU_Card_Full=yield tn(e),o.CPU_Cores=yield rn(),o.Which_Brainchop="latest",(yield he())&&(o.Heap_Size_MB=window.performance.memory.totalJSHeapSize/(1024*1024).toFixed(2),o.Used_Heap_MB=window.performance.memory.usedJSHeapSize/(1024*1024).toFixed(2),o.Heap_Limit_MB=window.performance.memory.jsHeapSizeLimit/(1024*1024).toFixed(2)),e){const i=e.getExtension("WEBGL_debug_renderer_info");o.Texture_Size=e.getParameter(e.MAX_TEXTURE_SIZE)}else o.Texture_Size=null;return o})}function cn(o){return new Worker("/assets/brainchop-webworker-DSv65GjU.js",{name:o==null?void 0:o.name})}function dn(){return x(this,null,function*(){dragMode.onchange=function(){return x(this,null,function*(){a.opts.dragMode=this.selectedIndex})},drawDrop.onchange=function(){return x(this,null,function*(){if(a.volumes.length<2){window.alert("No segmentation open (use the Segmentation pull down)"),drawDrop.selectedIndex=-1;return}if(!a.drawBitmap){window.alert("No drawing (hint: use the Draw pull down to select a pen)"),drawDrop.selectedIndex=-1;return}const p=parseInt(this.value);if(p===0){a.drawUndo(),drawDrop.selectedIndex=-1;return}let g=a.volumes[1].img,w=yield a.saveImage({filename:"",isSaveDrawing:!0});const y=352,P=w.length;if(p===1)for(let v=0;v<P;v++)w[y+v]>0&&(g[v]=1);if(p===2)for(let v=0;v<P;v++)w[y+v]>0&&(g[v]=0);a.closeDrawing(),a.updateGLVolume(),a.setDrawingEnabled(!1),penDrop.selectedIndex=-1,drawDrop.selectedIndex=-1})},penDrop.onchange=function(){return x(this,null,function*(){const p=parseInt(this.value);a.setDrawingEnabled(p>=0),p>=0&&a.setPenValue(p&7,p>7)})},aboutBtn.onclick=function(){window.alert("Drag and drop NIfTI images. Use pulldown menu to choose brainchop model")},diagnosticsBtn.onclick=function(){if(h.length<1){window.alert("No diagnostic string generated: run a model to create diagnostics");return}f=f.slice(0,-2),f!==""&&h.includes("Status: OK")&&(h=h.replace("Status: OK",`Status: ${f}`)),f="",navigator.clipboard.writeText(h),window.alert(`Diagnostics copied to clipboard
`+h)},opacitySlider0.oninput=function(){a.setOpacity(0,opacitySlider0.value/255),a.updateGLVolume()},opacitySlider1.oninput=function(){a.setOpacity(1,opacitySlider1.value/255)};function o(){return x(this,null,function*(){const p=a.volumes[0];let g=p.dims[1]===256&&p.dims[2]===256&&p.dims[3]===256&&p.img instanceof Uint8Array&&p.img.length===256*256*256;if((p.permRAS[0]!==-1||p.permRAS[1]!==3||p.permRAS[2]!==-2)&&(g=!1),g)return;const w=yield a.conform(p,!1);yield a.removeVolume(a.volumes[0]),yield a.addVolume(w)})}function e(){return x(this,null,function*(){for(;a.volumes.length>1;)yield a.removeVolume(a.volumes[1])})}modelSelect.onchange=function(){return x(this,null,function*(){this.selectedIndex<0&&(modelSelect.selectedIndex=11),yield e(),yield o();const p=k[this.selectedIndex],g=Ie,w=new URL(window.location.href);if(g.rootURL=w.origin+w.pathname,!!(window.location.hostname==="localhost"||window.location.hostname==="[::1]"||window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/))&&(g.rootURL=location.protocol+"//"+location.host),workerCheck.checked){if(typeof c!="undefined")return;c=yield new cn({});const P={datatypeCode:a.volumes[0].hdr.datatypeCode,dims:a.volumes[0].hdr.dims},v={opts:g,modelEntry:p,niftiHeader:P,niftiImage:a.volumes[0].img};c.postMessage(v),c.onmessage=function(S){const A=S.data.cmd;A==="ui"&&(S.data.modalMessage!==""&&(c.terminate(),c=void 0),m(S.data.message,S.data.progressFrac,S.data.modalMessage,S.data.statData)),A==="img"&&(c.terminate(),c=void 0,l(S.data.img,S.data.opts,S.data.modelEntry))}}else Ye(g,p,a.volumes[0].hdr,a.volumes[0].img,l,m)})},saveImgBtn.onclick=function(){a.volumes[1].saveToDisk("segmentaion.nii.gz")},saveSceneBtn.onclick=function(){a.saveDocument("brainchop.nvd")},workerCheck.onchange=function(){modelSelect.onchange()},clipCheck.onchange=function(){clipCheck.checked?a.setClipPlane([0,0,90]):a.setClipPlane([2,0,90])};function n(){opacitySlider0.oninput()}function i(p){return x(this,null,function*(){return yield(yield fetch(p)).json()})}function r(p){return x(this,null,function*(){const g=new Map;for(let y=0;y<p.length;y++){const P=p[y];g.has(P)?g.set(P,g.get(P)+1):g.set(P,1)}return Array.from(g,([y,P])=>({value:y,count:P}))})}function s(p,g){return x(this,null,function*(){return p.length!==g.length&&(f="Failed to Predict Labels - "),g.map((w,y)=>{const P=p.find(S=>S.value===y),v=P?`${P.count} mm3`:"Missing";return v==="Missing"&&(f+=`${w}, `),`${w}   ${v}`})})}function l(p,g,w){return x(this,null,function*(){e();const y=yield a.volumes[0].clone();y.zeroImage(),y.hdr.scl_inter=0,y.hdr.scl_slope=1,y.img=new Uint8Array(p);const P=yield r(y.img);if(w.colormapPath){const v=yield i(w.colormapPath),S=yield s(P,v.labels);y.setColormapLabel({R:v.R,G:v.G,B:v.B,labels:S}),y.hdr.intent_code=1002}else{let v=g.atlasSelectedColorTable.toLowerCase();a.colormaps().includes(v)||(v="actc"),y.colormap=v}y.opacity=opacitySlider1.value/255,yield a.addVolume(y)})}function t(p){return x(this,null,function*(){(typeof p=="string"||p instanceof String)&&(p=function(w){const y=JSON.parse(w),P=[];for(const v in y)P[v]=y[v];return P}(p)),p=yield ln(p,a.gl),h=`:: Diagnostics can help resolve issues https://github.com/neuroneural/brainchop/issues ::
`;for(const g in p)h+=g+": "+p[g]+`
`})}function m(p="",g=-1,w="",y=[]){p!==""&&(document.getElementById("location").innerHTML=p),isNaN(g)?(memstatus.style.color="red",memstatus.innerHTML="Memory Issue"):g>=0&&(modelProgress.value=g*modelProgress.max),w!==""&&window.alert(w),Object.keys(y).length>0&&t(y)}function d(p){document.getElementById("location").innerHTML=p.string.split("   ").map(g=>`<p style="font-size: 14px;margin:0px;">${g}</p>`).join("")}const u={backColor:[.4,.4,.4,1],show3Dcrosshair:!0,onLocationChange:d};let h="",f="",c;const a=new ye(u);a.attachToCanvas(gl1),a.opts.dragMode=a.dragModes.pan,a.opts.multiplanarForceRender=!0,a.opts.yoke3Dto2DZoom=!0,a.opts.crosshairGap=11,a.setInterpolation(!0),yield a.loadVolumes([{url:"./t1_crop.nii.gz"}]);for(let p=0;p<k.length;p++){const g=document.createElement("option");g.text=k[p].modelName,g.value=k[p].id.toString(),modelSelect.appendChild(g)}a.onImageLoaded=n,modelSelect.selectedIndex=-1,drawDrop.selectedIndex=-1,workerCheck.checked=yield he();const _=new URLSearchParams(window.location.search).get("model");_&&(modelSelect.selectedIndex=Number(_),modelSelect.onchange())})}function un(){return x(this,null,function*(){try{const e=yield(yield fetch("https://api.github.com/repos/neuroneural/brainchop")).json();document.getElementById("star-count").textContent=e.stargazers_count}catch(o){}})}(function(){return x(this,null,function*(){yield dn(),un()})})();
