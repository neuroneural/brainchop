var y=(r,e,o)=>new Promise((c,u)=>{var s=d=>{try{a(o.next(d))}catch(l){u(l)}},t=d=>{try{a(o.throw(d))}catch(l){u(l)}},a=d=>d.done?c(d.value):Promise.resolve(d.value).then(s,t);a((o=o.apply(r,e)).next())});import{N as We}from"./vendor-niivue-DkxzteUE.js";import{l as Re,t as ae,s as ke,d as Q,a as xe,b as ve,c as oe,e as Pe,E as ie,m as qe,o as ce,z as pe,f as I,g as ze,w as Se,h as Ge,i as Ce,j as Y,k as _e,n as je,p as Qe,q as He,r as Ue,u as ue,v as Xe,x as Le,y as fe}from"./vendor-tf-Blupv7mO.js";import"./vendor-DOCzr95M.js";import"./vendor-math-CA38DMGy.js";(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const u of document.querySelectorAll('link[rel="modulepreload"]'))c(u);new MutationObserver(u=>{for(const s of u)if(s.type==="childList")for(const t of s.addedNodes)t.tagName==="LINK"&&t.rel==="modulepreload"&&c(t)}).observe(document,{childList:!0,subtree:!0});function o(u){const s={};return u.integrity&&(s.integrity=u.integrity),u.referrerPolicy&&(s.referrerPolicy=u.referrerPolicy),u.crossOrigin==="use-credentials"?s.credentials="include":u.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function c(u){if(u.ep)return;u.ep=!0;const s=o(u);fetch(u.href,s)}})();const $e={batchSize:1,numOfChan:1,isColorEnable:!0,isAutoColors:!0,bgLabelValue:0,drawBoundingVolume:!1,isGPU:!0,isBrainCropMaskBased:!0,showPhase1Output:!1,isPostProcessEnable:!0,isContoursViewEnable:!1,browserArrayBufferMaxZDim:30,telemetryFlag:!1,chartXaxisStepPercent:10,uiSampleName:"BC_UI_Sample",atlasSelectedColorTable:"Fire"},ee=[{id:1,type:"Segmentation",path:"/models/model5_gw_ae/model.json",modelName:"âš¡ Tissue GWM (light)",colormapPath:"./models/model5_gw_ae/colormap3.json",preModelId:null,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:0,enableTranspose:!0,enableCrop:!0,cropPadding:18,autoThreshold:0,enableQuantileNorm:!1,filterOutWithPreMask:!1,enableSeqConv:!1,textureSize:0,warning:null,inferenceDelay:100,description:"Gray and white matter segmentation model. Operates on full T1 image in a single pass, but uses only 5 filters per layer. Can work on integrated graphics cards but is barely large enough to provide good accuracy. Still more accurate than the subvolume model."},{id:2,type:"Segmentation",path:"/models/model20chan3cls/model.json",modelName:"ðŸ”ª Tissue GWM (High Acc)",colormapPath:"./models/model20chan3cls/colormap.json",preModelId:null,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:0,enableTranspose:!0,enableCrop:!0,cropPadding:0,autoThreshold:.2,enableQuantileNorm:!0,filterOutWithPreMask:!1,enableSeqConv:!1,textureSize:0,warning:"This model may need dedicated graphics card.  For more info please check with Browser Resources <i class='fa fa-cogs'></i>.",inferenceDelay:100,description:"Gray and white matter segmentation model. Operates on full T1 image in a single pass but needs a dedicated graphics card to operate. Provides the best accuracy with hard cropping for better speed"},{id:3,type:"Segmentation",path:"/models/model20chan3cls/model.json",modelName:"ðŸ”ª Tissue GWM (High Acc, Low Mem)",colormapPath:"./models/model20chan3cls/colormap.json",preModelId:null,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:0,enableTranspose:!0,enableCrop:!0,cropPadding:0,autoThreshold:.2,enableQuantileNorm:!0,filterOutWithPreMask:!1,enableSeqConv:!0,textureSize:0,warning:"This model may need dedicated graphics card.  For more info please check with Browser Resources <i class='fa fa-cogs'></i>.",inferenceDelay:100,description:"Gray and white matter segmentation model. Operates on full T1 image in a single pass but needs a dedicated graphics card to operate. Provides high accuracy and fit low memory available but slower"},{id:4,type:"Atlas",path:"/models/model30chan18cls/model.json",modelName:"ðŸª“ Subcortical + GWM (High Mem, Fast)",colormapPath:"./models/model30chan18cls/colormap.json",preModelId:null,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:200,enableTranspose:!0,enableCrop:!0,cropPadding:0,autoThreshold:.2,enableQuantileNorm:!1,filterOutWithPreMask:!1,enableSeqConv:!1,textureSize:0,warning:"This model may need dedicated graphics card.  For more info please check with Browser Resources <i class='fa fa-cogs'></i>.",inferenceDelay:100,description:"Parcellation of the brain into 17 regions: gray and white matter plus subcortical areas. This is a robust model able to handle range of data quality, including varying saturation, and even clinical scans. It may work on infant brains, but your mileage may vary."},{id:5,type:"Atlas",path:"/models/model30chan18cls/model.json",modelName:"ðŸª“ Subcortical + GWM (Low Mem, Slow)",colormapPath:"./models/model30chan18cls/colormap.json",preModelId:null,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:200,enableTranspose:!0,enableCrop:!0,cropPadding:0,autoThreshold:.2,enableQuantileNorm:!1,filterOutWithPreMask:!1,enableSeqConv:!0,textureSize:0,warning:"This model may need dedicated graphics card.  For more info please check with Browser Resources <i class='fa fa-cogs'></i>.",inferenceDelay:100,description:"Parcellation of the brain into 17 regions: gray and white matter plus subcortical areas. This is a robust model able to handle range of data quality, including varying saturation, and even clinical scans. It may work on infant brains, but your mileage may vary."},{id:6,type:"Atlas",path:"/models/model18cls/model.json",modelName:"ðŸª“ Subcortical + GWM (Low Mem, Faster)",colormapPath:"./models/model18cls/colormap.json",preModelId:null,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:200,enableTranspose:!0,enableCrop:!0,cropPadding:0,autoThreshold:.2,enableQuantileNorm:!1,filterOutWithPreMask:!1,enableSeqConv:!0,textureSize:0,warning:"This model may need dedicated graphics card.  For more info please check with Browser Resources <i class='fa fa-cogs'></i>.",inferenceDelay:100,description:"Parcellation of the brain into 17 regions: gray and white matter plus subcortical areas. This is a robust model able to handle range of data quality, including varying saturation, and even clinical scans. It may work on infant brains, but your mileage may vary."},{id:7,type:"Atlas",path:"/models/model30chan18cls/model.json",modelName:"ðŸ”ªðŸª“ Subcortical + GWM (Failsafe, Less Acc)",colormapPath:"./models/model30chan18cls/colormap.json",preModelId:1,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:200,enableTranspose:!0,enableCrop:!0,cropPadding:0,autoThreshold:0,enableQuantileNorm:!1,filterOutWithPreMask:!1,enableSeqConv:!1,textureSize:0,warning:"This model may need dedicated graphics card.  For more info please check with Browser Resources <i class='fa fa-cogs'></i>.",inferenceDelay:100,description:"Parcellation of the brain into 17 regions: gray and white matter plus subcortical areas. This is not a robust model, it may work on low data quality, including varying saturation, and even clinical scans. It may work also on infant brains, but your mileage may vary."},{id:8,type:"Atlas",path:"/models/model30chan50cls/model.json",modelName:"ðŸ”ª Aparc+Aseg 50 (High Mem, Fast)",colormapPath:"./models/model30chan50cls/colormap.json",preModelId:1,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:200,enableTranspose:!0,enableCrop:!0,cropPadding:0,autoThreshold:0,enableQuantileNorm:!0,filterOutWithPreMask:!1,enableSeqConv:!1,textureSize:0,warning:"This model may need dedicated graphics card.  For more info please check with Browser Resources <i class='fa fa-cogs'></i>.",inferenceDelay:100,description:"This is a 50-class model, that segments the brain into the Aparc+Aseg Freesurfer Atlas but one where cortical homologues are merged into a single class."},{id:9,type:"Atlas",path:"/models/model30chan50cls/model.json",modelName:"ðŸ”ª Aparc+Aseg 50 (Low Mem, Slow)",colormapPath:"./models/model30chan50cls/colormap.json",preModelId:1,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:200,enableTranspose:!0,enableCrop:!0,cropPadding:0,autoThreshold:0,enableQuantileNorm:!0,filterOutWithPreMask:!1,enableSeqConv:!0,textureSize:0,warning:"This model may need dedicated graphics card.  For more info please check with Browser Resources <i class='fa fa-cogs'></i>.",inferenceDelay:100,description:"This is a 50-class model, that segments the brain into the Aparc+Aseg Freesurfer Atlas but one where cortical homologues are merged into a single class. The model use sequential convolution for inference to overcome browser memory limitations but leads to longer computation time."},{id:10,type:"Brain_Extraction",path:"/models/model5_gw_ae/model.json",modelName:"âš¡ Extract the Brain (FAST)",preModelId:null,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:0,enableTranspose:!0,enableCrop:!0,cropPadding:18,autoThreshold:0,enableQuantileNorm:!1,filterOutWithPreMask:!1,enableSeqConv:!1,textureSize:0,warning:null,inferenceDelay:100,description:"Extract the brain fast model operates on full T1 image in a single pass, but uses only 5 filters per layer. Can work on integrated graphics cards but is barely large enough to provide good accuracy. Still more accurate than the failsafe version."},{id:11,type:"Brain_Extraction",path:"/models/model11_gw_ae/model.json",modelName:"ðŸ”ª Extract the Brain (High Acc, Slow)",preModelId:null,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:0,enableTranspose:!0,enableCrop:!0,cropPadding:0,autoThreshold:0,enableQuantileNorm:!1,filterOutWithPreMask:!1,enableSeqConv:!0,textureSize:0,warning:"This model may need dedicated graphics card.  For more info please check with Browser Resources <i class='fa fa-cogs'></i>.",inferenceDelay:100,description:"Extract the brain high accuracy model operates on full T1 image in a single pass, but uses only 11 filters per layer. Can work on dedicated graphics cards. Still more accurate than the fast version."},{id:12,type:"Brain_Masking",path:"/models/model5_gw_ae/model.json",modelName:"âš¡ Brain Mask (FAST)",colormapPath:"./models/model5_gw_ae/colormap.json",preModelId:null,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:0,enableTranspose:!0,enableCrop:!0,cropPadding:17,autoThreshold:0,enableQuantileNorm:!1,filterOutWithPreMask:!1,enableSeqConv:!1,textureSize:0,warning:null,inferenceDelay:100,description:"This fast masking model operates on full T1 image in a single pass, but uses only 5 filters per layer. Can work on integrated graphics cards but is barely large enough to provide good accuracy. Still more accurate than failsafe version."},{id:13,type:"Brain_Masking",path:"/models/model11_gw_ae/model.json",modelName:"ðŸ”ª Brain Mask (High Acc, Low Mem)",preModelId:null,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:0,enableTranspose:!0,enableCrop:!0,cropPadding:0,autoThreshold:0,enableQuantileNorm:!0,filterOutWithPreMask:!1,enableSeqConv:!0,textureSize:0,warning:"This model may need dedicated graphics card.  For more info please check with Browser Resources <i class='fa fa-cogs'></i>.",inferenceDelay:100,description:"This masking model operates on full T1 image in a single pass, but uses 11 filters per layer. Can work on dedicated graphics cards. Still more accurate than fast version."},{id:14,type:"Atlas",path:"/models/model21_104class/model.json",modelName:"ðŸ”ª Aparc+Aseg 104 (High Mem, Fast)",colormapPath:"./models/model21_104class/colormap.json",preModelId:1,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:200,enableTranspose:!0,enableCrop:!0,cropPadding:0,autoThreshold:0,enableQuantileNorm:!1,filterOutWithPreMask:!1,enableSeqConv:!1,textureSize:0,warning:"This model may need dedicated graphics card.  For more info please check with Browser Resources <i class='fa fa-cogs'></i>.",inferenceDelay:100,description:"FreeSurfer aparc+aseg atlas 104 parcellate brain areas into 104 regions. It contains a combination of the Desikan-Killiany atlas for cortical area and also segmentation of subcortical regions."},{id:15,type:"Atlas",path:"/models/model21_104class/model.json",modelName:"ðŸ”ª Aparc+Aseg 104 (Low Mem, Slow)",colormapPath:"./models/model21_104class/colormap.json",preModelId:null,preModelPostProcess:!1,isBatchOverlapEnable:!1,numOverlapBatches:200,enableTranspose:!0,enableCrop:!0,cropPadding:0,autoThreshold:0,enableQuantileNorm:!1,filterOutWithPreMask:!1,enableSeqConv:!0,textureSize:0,warning:"This model may need dedicated graphics card.  For more info please check with Browser Resources <i class='fa fa-cogs'></i>.",inferenceDelay:100,description:"FreeSurfer aparc+aseg atlas 104 parcellate brain areas into 104 regions. It contains a combination of the Desikan-Killiany atlas for cortical area and also segmentation of subcortical regions. The model use sequential convolution for inference to overcome browser memory limitations but leads to longer computation time. "}];class Ke{idx(e,o,c,u){return c*u[0]*u[1]+o*u[0]+e}check_previous_slice(e,o,c,u,s,t,a,d,l,n){let h=0;if(!s)return 0;const m=e[this.idx(c,u,s,t)];if(a>=6){const p=this.idx(c,u,s-1,t);m===e[p]&&(l[h++]=o[p])}if(a>=18){if(c){const p=this.idx(c-1,u,s-1,t);m===e[p]&&(l[h++]=o[p])}if(u){const p=this.idx(c,u-1,s-1,t);m===e[p]&&(l[h++]=o[p])}if(c<t[0]-1){const p=this.idx(c+1,u,s-1,t);m===e[p]&&(l[h++]=o[p])}if(u<t[1]-1){const p=this.idx(c,u+1,s-1,t);m===e[p]&&(l[h++]=o[p])}}if(a===26){if(c&&u){const p=this.idx(c-1,u-1,s-1,t);m===e[p]&&(l[h++]=o[p])}if(c<t[0]-1&&u){const p=this.idx(c+1,u-1,s-1,t);m===e[p]&&(l[h++]=o[p])}if(c&&u<t[1]-1){const p=this.idx(c-1,u+1,s-1,t);m===e[p]&&(l[h++]=o[p])}if(c<t[0]-1&&u<t[1]-1){const p=this.idx(c+1,u+1,s-1,t);m===e[p]&&(l[h++]=o[p])}}return h?(this.fill_tratab(d,l,h,n),l[0]):0}do_initial_labelling(e,o,c){const u=new Uint32Array(32),s=new Uint32Array(32);let t=1;const a=8192;let d=a,l=new Uint32Array(d).fill(0);const n=new Uint32Array(o[0]*o[1]*o[2]).fill(0),h=new Uint32Array(27);for(let m=0;m<o[2];m++)for(let p=0;p<o[1];p++)for(let i=0;i<o[0];i++){let S=0;const M=e[this.idx(i,p,m,o)];if(M!==0){if(h[0]=this.check_previous_slice(e,n,i,p,m,o,c,l,u,s),h[0]&&(S+=1),c>=6){if(i){const f=this.idx(i-1,p,m,o);M===e[f]&&(h[S++]=n[f])}if(p){const f=this.idx(i,p-1,m,o);M===e[f]&&(h[S++]=n[f])}}if(c>=18){if(p&&i){const f=this.idx(i-1,p-1,m,o);M===e[f]&&(h[S++]=n[f])}if(p&&i<o[0]-1){const f=this.idx(i+1,p-1,m,o);M===e[f]&&(h[S++]=n[f])}}if(S)n[this.idx(i,p,m,o)]=h[0],this.fill_tratab(l,h,S,s);else{if(n[this.idx(i,p,m,o)]=t,t>=d){d+=a;const f=new Uint32Array(d);f.set(l),l=f}l[t-1]=t,t++}}}for(let m=0;m<t-1;m++){let p=m;for(;l[p]!==p+1;)p=l[p]-1;l[m]=p+1}return[t-1,l,n]}fill_tratab(e,o,c,u){let t=2147483647;for(let a=0;a<c;a++){let d=o[a];for(;e[d-1]!==d;)d=e[d-1];u[a]=d,t=Math.min(t,d)}for(let a=0;a<c;a++)e[u[a]-1]=t}translate_labels(e,o,c,u){const s=o[0]*o[1]*o[2];let t=0;const a=new Uint32Array(s).fill(0);for(let n=0;n<u;n++)t=Math.max(t,c[n]);const d=new Uint32Array(t).fill(0);let l=0;for(let n=0;n<s;n++)e[n]&&(d[c[e[n]-1]-1]||(l+=1,d[c[e[n]-1]-1]=l),a[n]=d[c[e[n]-1]-1]);return[l,a]}largest_original_cluster_labels(e,o,c){const u=e.length,s=new Uint32Array(o+1).fill(0),t=new Uint32Array(o+1).fill(0);for(let l=0;l<u;l++){const n=e[l],h=c[l];s[h]=n,t[h]++}let a=0;for(let l=0;l<o+1;l++){const n=s[l];a=Math.max(a,n);for(let h=0;h<o+1;h++)h!==l&&n===s[h]&&(t[l]<t[h]||t[l]===t[h]&&l<h)&&(s[l]=0)}const d=new Uint32Array(u).fill(0);for(let l=0;l<u;l++)d[l]=s[c[l]];return[a,d]}bwlabel(e,o,c=26,u=!1,s=!1){const t=Date.now(),a=o[0]*o[1]*o[2],d=new Uint32Array(a).fill(0);if(![6,18,26].includes(c))return[0,d];if(o[0]<2||o[1]<2||o[2]<1)return[0,d];if(u)for(let i=0;i<a;i++)e[i]!==0&&(d[i]=1);else d.set(e);let[l,n,h]=this.do_initial_labelling(d,o,c);n===void 0&&(n=new Uint32Array(0));const[m,p]=this.translate_labels(h,o,n,l);if(s){const[i,S]=this.largest_original_cluster_labels(d,m,p);return[i,S]}return[m,p]}}function Oe(u){return y(this,arguments,function*(r,e=[1,1],o=[1,1],c=[1,1]){if(r.rank!==3)throw new Error("Tensor must be 3D");return r.pad([e,o,c])})}function Ie(r,e){return y(this,null,function*(){const o=r.max(),c=o.mul(e),u=yield c.data();return o.dispose(),c.dispose(),oe(()=>r.clone().greater(u[0]))})}function he(r){return y(this,null,function*(){return r.step(0)})}function Ze(r,e=.01,o=.99){return y(this,null,function*(){const c=r.flatten(),u=yield c.array();u.sort((p,i)=>p-i);const s=ve(u),t=s.shape[0],a=Math.floor(t*e),d=Math.ceil(t*o)-1,l=s.slice(a,1),n=s.slice(d,1),h=(yield l.array())[0],m=(yield n.array())[0];return c.dispose(),s.dispose(),l.dispose(),n.dispose(),{qmin:h,qmax:m}})}function Je(r,e,o,c,u,s,t){return y(this,null,function*(){const a=r.shape[4],d=e.shape[4];let l=null;for(let n=0;n<d;n++){const h=Math.ceil(a/t),m=o.slice([n],[1]);let p=null;for(let S=0;S<h;S++){const M=S*t,f=Math.min((S+1)*t,a);if(M<a){const g=oe(()=>{const w=r.slice([0,0,0,0,M],[-1,-1,-1,-1,f-M]),_=e.slice([0,0,0,M,n],[-1,-1,-1,f-M,1]);return Pe(w,_,c,u,"NDHWC",s)});if(p===null)p=g;else{const w=p.add(g);p.dispose(),g.dispose(),p=w}}}const i=p.add(m);if(p.dispose(),m.dispose(),l==null)l=i;else{const S=yield Qe([l,i],4);i.dispose(),l.dispose(),l=S}}return l})}function Ae(r,e,o,c){return y(this,null,function*(){const u=[];for(let l=0;l<r.length;l++)u[l]=Array.from(r[l].dataSync());const s=new Array(u[0].length*u.length);let t=0;for(let l=0;l<u.length;l++)for(let n=0;n<u[l].length;n++)s[t++]=u[l][n];const a=yield he(ve(s)),d=Array.from(a.dataSync());c(d,e,o)})}function de(r,e=0){return y(this,null,function*(){let o=[];e===0?o=yield r.max(2).max(1).arraySync():e===1?o=yield r.max(2).max(0).arraySync():o=yield r.max(1).max(0).arraySync();let c=o.length,u=0;for(let s=0;s<o.length;s++)if(o[s]>0){c=s;break}for(let s=o.length-1;s>=0;s--)if(o[s]>0){u=s;break}return[c,u]})}function Be(r){return y(this,null,function*(){const[e,o]=yield de(r,0),[c,u]=yield de(r,1),[s,t]=yield de(r,2);return[e,o,c,u,s,t]})}function Ye(r,e,o,c,u,s,t,a,d=!0){return y(this,null,function*(){r[0].dtype!=="int32"&&t("",-1,"generateBrainMask assumes int32"),u.preModelPostProcess&&t("",-1,"generateBrainMask assumes BWLabeler instead of preModelPostProcess");const l=r.length,n=r[0].size,h=l*n,m=new Int32Array(h);let p=0;for(let i=0;i<l;i++)m.set(r[i].dataSync(),p),p+=n;for(let i=0;i<h;i++)m[i]=m[i]!==0?1:0;return(d||s.showPhase1Output)&&(a(m,s,u),t("Segmentation finished",0)),ae(m,[e,o,c])})}function Ee(r,e,o,c,u,s,t,a,d,l){return y(this,null,function*(){if(d.isPostProcessEnable){const h=new Ke,m=new Uint32Array(e),p=26,i=!0,S=!0,[M,f]=h.bwlabel(r,m,p,i,S);for(let g=0;g<r.length;g++)r[g]*=f[g]}const n=new Uint8Array(r);switch(a.type){case"Brain_Masking":{const h=new Uint8Array(n.length);for(let m=0;m<n.length;m++)h[m]=n[m]!==0?1:0;return h}case"Brain_Extraction":{const h=new Uint8Array(n.length);for(let m=0;m<n.length;m++){const p=n[m]!==0?1:0;h[m]=l[m]*p}return h}}return r})}function De(r,e,o){return y(this,null,function*(){const c=e.dims[1],u=e.dims[2];let s;if(e.datatypeCode===2)s=new Uint8Array(o);else if(e.datatypeCode===4)s=new Int16Array(o);else if(e.datatypeCode===8)s=new Int32Array(o);else if(e.datatypeCode===16)s=new Float32Array(o);else if(e.datatypeCode===64)s=new Float64Array(o);else if(e.datatypeCode===256)s=new Int8Array(o);else if(e.datatypeCode===512)s=new Uint16Array(o);else if(e.datatypeCode===768)s=new Uint32Array(o);else return;const t=[];let a=0;for(let l=0;l<r;l++){const n=new Array(u*c);let h=0;for(let m=0;m<u;m++)for(let p=0;p<c;p++){const i=s[a++];n[h++]=i&255}t.push(ae(n,[u,c]))}const d=ke(t);return Q(t),d})}function me(r){return y(this,null,function*(){return r.layers.length})}function ge(r){return y(this,null,function*(){let e=0;for(let o=0;o<r.layers.length;o++)e+=r.layers[o].countParams();return e})}function te(r){return y(this,null,function*(){for(let e=0;e<r.layers.length;e++)if(r.layersByDepth[e][0].dataFormat)return r.layersByDepth[e][0].dataFormat==="channelsLast"})}function Ne(r){return y(this,null,function*(){return yield Re(r)})}function ye(r){return y(this,null,function*(){const e=r.max(),o=r.min();return yield r.sub(o).div(e.sub(o))})}function eo(r,e,o){const t=r.shape[4],a=Math.ceil(t/o);let d=null;for(let l=0;l<a;l++){const n=l*o,m=Math.min((l+1)*o,t)-n,p=oe(()=>r.slice([0,0,0,0,n],[-1,-1,-1,-1,m])),i=oe(()=>e.slice([0,0,0,n,0],[-1,-1,-1,m,-1])),S=Pe(p,i,1,0,"NDHWC",1);p.dispose(),i.dispose();const M=je(S);if(S.dispose(),d===null)d=M;else{const f=d.add(M);d.dispose(),d!==M&&M.dispose(),d=f}oe(()=>{Ce(pe([1,1]),pe([1,1]))})}return d}function we(r,e=.05,o=.95){return y(this,null,function*(){const{qmin:c,qmax:u}=yield Ze(r,e,o),s=xe(c),t=xe(u),a=r.sub(s).div(t.sub(s));return s.dispose(),t.dispose(),a})}function re(r,e=1,o=1,c=1){return y(this,null,function*(){if(r.rank!==3)throw new Error("Tensor must be 3D");const[u,s,t]=r.shape;return r.slice([e,o,c],[u-2*e,s-2*o,t-2*c])})}function se(r,e,o,c,u,s){return y(this,null,function*(){const t=u[0],a=u[1],d=u[2],l=t+s[0]-1,n=a+s[1]-1,h=d+s[2]-1,m=o-l-1>0?o-l-1:0,p=c-n-1>0?c-n-1:0,i=e-h-1>0?e-h-1:0;return r.pad([[t,m],[a,p],[d,i]])})}class oo{constructor(e,o,c,u,s=!0){this.model=e,this.outChannels=e.outputLayers[0].kernel.shape[4],this.chunkSize=o,this.isChannelLast=c,this.callbackUI=u,this.isWebWorker=s}apply(e){return y(this,null,function*(){const o=ie.get("WEBGL_DELETE_TEXTURE_THRESHOLD");ie.set("WEBGL_DELETE_TEXTURE_THRESHOLD",0);const c=this,u=performance.now(),s=c.model.layers[c.model.layers.length-1],t=s.getWeights()[0],a=s.getWeights()[1],d=c.isChannelLast?e.shape.slice(1,-1):e.shape.slice(2);let l=qe(ce(d),-1e4),n=pe(d),h=0;for(;;){I().startScope();const m=yield oe(()=>{const i=t.slice([0,0,0,0,h],[-1,-1,-1,-1,1]),S=a.slice([h],[1]),M=eo(e,i,Math.min(c.chunkSize,c.outChannels)).add(S),f=ze(M,l),g=Se(f,M,l),w=Se(f,Ge(n.shape,h),n);return Q([l,n,i,S,M,f]),oe(()=>Ce(ce([1,1]),ce([1,1]))),[w,g]});if(c.callbackUI(`Iteration ${h}`,h/c.outChannels),c.isWebWorker||(yield new Promise(i=>setTimeout(i,17))),(yield Y()).unreliable,typeof n!="undefined"&&n.dispose(),typeof l!="undefined"&&l.dispose(),n=_e(m[0]),l=_e(m[1]),I().endScope(),h===c.outChannels-1){Q(l);const S=performance.now()-u;return ie.set("WEBGL_DELETE_TEXTURE_THRESHOLD",o),n}else{h++;const i=n.shape,S=n.dataSync(),M=n.shape,f=l.dataSync();n.dispose(),l.dispose(),n=ae(S,i),l=ae(f,M)}}})}}function Me(r,e,o,c,u,s,t,a,d,l,n,h){return y(this,null,function*(){e.enableQuantileNorm?c=yield we(c):c=yield ye(c);let p;if(a==null){const B=e.autoThreshold;B>0&&B<=1?p=yield Ie(c,B):p=yield c.greater([0]).asType("bool")}else p=yield a.greater([0]).asType("bool");const[i,S,M,f,g,w]=yield Be(p);p.dispose();const _=[i,M,g],L=[S-i+1,f-M+1,w-g+1],T=yield c.slice([i,M,g],[S-i+1,f-M+1,w-g+1]);c.dispose();const b=e.cropPadding;let P=yield Oe(T,[b,b],[b,b],[b,b]);if(T.dispose(),r.drawBoundingVolume){let B=yield re(P,b,b,b);return B=yield se(B,u,s,t,_,L),Ae(fe(B),r,e,l),B.dispose(),0}n.Brainchop_Ver="FullVolume";const x=yield o;try{let B=performance.now();const U=performance.now();let A=0;const O=e.enableTranspose,D=e.inferenceDelay;O&&(P=yield P.transpose());let C=1;const $=x.layers.length,v=te(x),X=r.batchSize,k=r.numOfChan;let K;v?(x.layers[0].batchInputShape[1]=P.shape[0],x.layers[0].batchInputShape[2]=P.shape[1],x.layers[0].batchInputShape[3]=P.shape[2],K=[X,x.layers[0].batchInputShape[1],x.layers[0].batchInputShape[2],x.layers[0].batchInputShape[3],k]):(x.layers[0].batchInputShape[2]=P.shape[0],x.layers[0].batchInputShape[3]=P.shape[1],x.layers[0].batchInputShape[4]=P.shape[2],K=[X,k,x.layers[0].batchInputShape[2],x.layers[0].batchInputShape[3],x.layers[0].batchInputShape[4]]),n.Input_Shape=JSON.stringify(x.layers[0].batchInputShape),n.Output_Shape=JSON.stringify(x.output.shape),n.Channel_Last=v,n.Model_Param=yield ge(x),n.Model_Layers=yield me(x),n.Model=e.modelName,n.Seq_Conv=e.enableSeqConv,n.Extra_Info=null;const Z=x.layers[x.layers.length-1],V=v?Z.outputShape[Z.outputShape.length-1]:Z.outputShape[1],F=[];F[0]=yield P.reshape(K);const q=window.setInterval(function(){return y(this,null,function*(){try{x.layers[C].activation.getClassName()!=="linear"?F[C]=yield x.layers[C].apply(F[C-1]):F[C]=yield Je(F[C-1],x.layers[C].getWeights()[0],x.layers[C].getWeights()[1],x.layers[C].strides,x.layers[C].padding,x.layers[C].dilationRate,3),Q(F[C-1])}catch(W){const R="Your graphics card (e.g. Intel) may not be compatible with WebGL. "+W.message;return d(R,-1,R),window.clearInterval(q),I().endScope(),I().disposeVariables(),n.Inference_t=1/0,n.Postprocess_t=1/0,n.Status="Fail",n.Error_Type=W.message,n.Extra_Err_Info="Failed while model layer "+C+" apply",d("",-1,"",n),0}if(x.layers[C].dispose(),F[C-1].dispose(),d("Layer "+C.toString(),(C+1)/$),Y().unreliable){const W="unreliable reasons :"+Y().reasons;d(W,NaN,W)}if(C===$-2){window.clearInterval(q);const R=yield(yield new oo(x,10,v,d,!1)).apply(F[C]);if(d("seqConvLayer Done"),Q(F[C]),R.shape.length!==3){const N="Output tensor shape should be 3 dims but it is "+R.shape.length;d(N,-1,N)}const z=yield R.max().dataSync()[0],G=((performance.now()-B)/1e3).toFixed(4);A<z&&(A=z);const j=A+1;if(n.Actual_Labels=j,n.Expect_Labels=V,n.NumLabels_Match=j===V,j!==V){const N="expected "+V+" labels, but the predicted are "+j;d(N,-1,N)}let E=R.reshape([P.shape[0],P.shape[1],P.shape[2]]);Q(R),O&&(E=E.transpose()),E=yield re(E,b,b,b),E=yield se(E,u,s,t,_,L);const le=e.filterOutWithPreMask;if(a!=null&&r.isBrainCropMaskBased&&le){const N=yield he(a);E=yield E.mul(N)}B=performance.now();let ne;try{const N=yield new Uint32Array(E.dataSync()),J=E.shape,Ve=E.dtype;ne=yield Ee(N,J,Ve,u,j,s,t,e,r,h),Q(E),I().endScope(),I().disposeVariables()}catch(N){I().endScope(),I().disposeVariables();const J="Failed while generating output due to limited browser memory available";return d(J,-1,J),n.Inference_t=G,n.Postprocess_t=1/0,n.Status="Fail",n.Error_Type=N.message,n.Extra_Err_Info="Failed while generating output",d("",-1,"",n),0}const H=((performance.now()-B)/1e3).toFixed(4);return n.Inference_t=G,n.Postprocess_t=H,n.Status="OK",d("",-1,"",n),d("Segmentation finished",0),l(ne,r,e),0}else C++})},D)}catch(B){if(d(B.message,-1,B.message),Y().unreliable){const U="unreliable reasons :"+Y().reasons;d(U,NaN,U)}}})}function Te(r,e,o,c,u,s,t,a,d,l,n,h){return y(this,null,function*(){let m=[];t.enableQuantileNorm?e=yield we(e):e=yield ye(e);let i;if(s==null){const O=t.autoThreshold;O>0&&O<=1?i=yield Ie(e,O):i=yield e.greater([0]).asType("bool")}else i=s.greater([0]).asType("bool");const[S,M,f,g,w,_]=yield Be(i);i.dispose();const L=[S,f,w],T=[M-S+1,g-f+1,_-w+1],b=e.slice([S,f,w],[M-S+1,g-f+1,_-w+1]);e.dispose();const P=t.cropPadding;let x=yield Oe(b,[P,P],[P,P],[P,P]);if(b.dispose(),d.drawBoundingVolume){let O=yield re(x,P,P,P);return O=yield se(O,o,c,u,L,T),Ae(fe(O),d,t,l),O.dispose(),0}a.Brainchop_Ver="FullVolume";let B=performance.now(),U=[];const A=yield r;try{B=performance.now();const O=performance.now();let D=0;const C=t.enableTranspose,$=t.inferenceDelay;C&&(x=x.transpose());let v=1;const X=A.layers.length,k=yield te(A),K=d.batchSize,Z=d.numOfChan;k?(A.layers[0].batchInputShape[1]=x.shape[0],A.layers[0].batchInputShape[2]=x.shape[1],A.layers[0].batchInputShape[3]=x.shape[2],U=[K,A.layers[0].batchInputShape[1],A.layers[0].batchInputShape[2],A.layers[0].batchInputShape[3],Z]):(A.layers[0].batchInputShape[2]=x.shape[0],A.layers[0].batchInputShape[3]=x.shape[1],A.layers[0].batchInputShape[4]=x.shape[2],U=[K,Z,A.layers[0].batchInputShape[2],A.layers[0].batchInputShape[3],A.layers[0].batchInputShape[4]]),a.Input_Shape=JSON.stringify(A.layers[0].batchInputShape),a.Output_Shape=JSON.stringify(A.output.shape),a.Channel_Last=k,a.Model_Param=yield ge(A),a.Model_Layers=yield me(A),a.Model=t.modelName,a.Extra_Info=null;const V=[];V[0]=x.reshape(U);const F=window.setInterval(function(){return y(this,null,function*(){try{V[v]=A.layers[v].apply(V[v-1])}catch(q){return n(q.message,-1,q.message),window.clearInterval(F),I().endScope(),I().disposeVariables(),a.Inference_t=1/0,a.Postprocess_t=1/0,a.Status="Fail",a.Error_Type=q.message,a.Extra_Err_Info="Failed while model layer "+v+" apply",n("",-1,"",a),0}if(n("Layer "+v.toString(),(v+1)/X),A.layers[v].dispose(),V[v-1].dispose(),Y().unreliable){const q="unreliable reasons :"+Y().reasons;n(q,NaN,q)}if(v===X-1){window.clearInterval(F);const q=k?-1:1,W=k?V[v].shape[4]:V[v].shape[1];let R;try{const H=performance.now();R=Le(V[v],q)}catch(H){if(q===-1)try{const N=performance.now();window.alert("tensor2LightBuffer() is not dead code?"),window.alert("argMaxLarge() is not dead code?")}catch(N){const J="argMax buffer couldn't be created due to limited memory resources.";return n(J,-1,J),window.clearInterval(F),I().endScope(),I().disposeVariables(),a.Inference_t=1/0,a.Postprocess_t=1/0,a.Status="Fail",a.Error_Type=N.message,a.Extra_Err_Info="prediction_argmax from argMaxLarge failed",n("",-1,"",a),0}else{const N="argMax buffer couldn't be created due to limited memory resources.";return n(N,-1,N),R.dispose(),window.clearInterval(F),I().endScope(),I().disposeVariables(),a.Inference_t=1/0,a.Postprocess_t=1/0,a.Status="Fail",a.Error_Type=H.message,a.Extra_Err_Info="prediction_argmax from argMaxLarge not support yet channel first",n("",-1,"",a),0}}const z=((performance.now()-B)/1e3).toFixed(4);Q(V[v]);const G=yield R.max().dataSync()[0];D<G&&(D=G);const j=D+1;if(a.Actual_Labels=j,a.Expect_Labels=W,a.NumLabels_Match=j===W,j!==W){const H="expected "+W+" labels, but the predicted are "+j;n(H,-1,H)}let E=R.reshape([x.shape[0],x.shape[1],x.shape[2]]);Q(R),C&&(E=E.transpose()),E=yield re(E,P,P,P),E=yield se(E,o,c,u,L,T);const le=t.filterOutWithPreMask;if(s!=null&&d.isBrainCropMaskBased&&le){const H=he(s);E=E.mul(H)}B=performance.now();try{const H=new Uint32Array(E.dataSync()),N=E.shape,J=E.dtype;Q(E),I().endScope(),I().disposeVariables(),m=yield Ee(H,N,J,o,j,c,u,t,d,h)}catch(H){I().endScope(),I().disposeVariables();const N="Failed while generating output due to limited browser memory available";return n(N,-1,N),a.Inference_t=z,a.Postprocess_t=1/0,a.Status="Fail",a.Error_Type=H.message,a.Extra_Err_Info="Failed while generating output",n("",-1,"",a),0}const ne=((performance.now()-B)/1e3).toFixed(4);return I().disposeVariables(),a.Inference_t=z,a.Postprocess_t=ne,a.Status="OK",n("",-1,"",a),clearInterval(F),n("Segmentation finished",0),l(m,d,t),0}v++})},$)}catch(O){n(O.message,-1,O.message)}})}function no(r,e,o,c,u,s,t,a,d,l,n,h){return y(this,null,function*(){if(a.No_SubVolumes=1,t.preModelId){const m=yield Ne(d.rootURL+ee[t.preModelId-1].path),p=ee[t.preModelId-1].enableTranspose,i=ee[t.preModelId-1].enableQuantileNorm;let S=null;i?S=yield we(e):S=yield ye(e),p&&(S=yield S.transpose()),a.Brainchop_Ver="PreModel_FV";const M=yield m;try{const f=performance.now(),g=M,w=g.layers[0].batchInputShape;if(w.length!==5){const v="The pre-model input shape must be 5D ";return n(v,-1,v),0}const _=te(g),L=d.batchSize,T=d.numOfChan;let b,P,x,B;if(_){if(isNaN(w[4])||w[4]!==1){const v="The number of channels for pre-model input shape must be 1";return n(v,-1,v),0}b=w[1],P=w[2],x=w[3],B=[L,b,P,x,T]}else{if(isNaN(w[1])||w[1]!==1){const v="The number of channels for pre-model input shape must be 1";return n(v,-1,v),0}b=w[2],P=w[3],x=w[4],B=[L,T,b,P,x]}a.Input_Shape=JSON.stringify(B),a.Output_Shape=JSON.stringify(g.output.shape),a.Channel_Last=_,a.Model_Param=yield ge(g),a.Model_Layers=yield me(g);let U=0;const A=ee[t.preModelId-1].inferenceDelay;let O=1;const D=M.layers.length,C=[];C[0]=S.reshape(B),Q(S);const $=window.setInterval(function(){return y(this,null,function*(){try{C[O]=yield M.layers[O].apply(C[O-1])}catch(v){const X="Your graphics card (e.g. Intel) may not be compatible with WebGL. "+v.message;return n(X,-1,X),window.clearInterval($),I().endScope(),I().disposeVariables(),a.Inference_t=1/0,a.Postprocess_t=1/0,a.Status="Fail",a.Error_Type=v.message,a.Extra_Err_Info="PreModel Failed while model layer "+O+" apply",n("",-1,"",a),0}if(M.layers[O].dispose(),C[O-1].dispose(),n("Layer "+O.toString(),(O+1)/D),Y().unreliable){const v="unreliable reasons :"+Y().reasons;n(v,NaN,v)}if(O===D-1){window.clearInterval($);const v=_?-1:1,X=_?C[O].shape[4]:C[O].shape[1];let k;try{k=yield Le(C[O],v)}catch(z){if(v===-1)try{const G=performance.now();window.alert("tensor2LightBuffer() is not dead code?"),window.alert("argMaxLarge() is not dead code?")}catch(G){const j="argMax buffer couldn't be created due to limited memory resources.";return n(j,-1,j),k.dispose(),window.clearInterval($),I().endScope(),I().disposeVariables(),a.Inference_t=1/0,a.Postprocess_t=1/0,a.Status="Fail",a.Error_Type=G.message,a.Extra_Err_Info="preModel prediction_argmax from argMaxLarge failed",n("",-1,"",a),0}else{const G="argMax buffer couldn't be created due to limited memory resources.";return n(G,-1,G),k.dispose(),window.clearInterval($),I().endScope(),I().disposeVariables(),a.Inference_t=1/0,a.Postprocess_t=1/0,a.Status="Fail",a.Error_Type=z.message,a.Extra_Err_Info="preModel prediction_argmax from argMaxLarge not support yet channel first",n("",-1,"",a),0}}const K=((performance.now()-f)/1e3).toFixed(4);Q(C[O]);const Z=yield k.max().dataSync()[0];U<Z&&(U=Z);const V=U+1;a.Actual_Labels=V,a.Expect_Labels=X,a.NumLabels_Match=V===X;let F=yield k.reshape([o,c,u]);Q(k),p&&(F=F.transpose());const q=performance.now();let W;try{const z=yield fe(F);W=yield Ye(z,o,c,u,t,d,n,l,!1),yield Q(F)}catch(z){I().endScope(),I().disposeVariables();const G="Failed while generating pre-model output due to limited browser memory available";return n(G,-1,G),a.Inference_t=K,a.Postprocess_t=1/0,a.Status="Fail",a.Error_Type=z.message,a.Extra_Err_Info="Pre-model failed while generating output",n("",-1,"",a),0}const R=((performance.now()-q)/1e3).toFixed(4);if(a.Inference_t=K,a.Postprocess_t=R,a.Status="OK",n("",-1,"",a),W==null){const z="slice_3d_mask failed ...";return n(z,-1,z),0}else if(s){if(t.enableSeqConv)return yield Me(d,t,r,e,o,c,u,W,n,l,a,h),0;yield Te(r,e,o,c,u,W,t,a,d,l,n,h)}else window.alert("inferenceSubVolumes() is not dead code?")}O++})},A)}catch(f){n(f.message,-1,f.message)}}else s?t.enableSeqConv?yield Me(d,t,r,e,o,c,u,null,n,l,a,h):Te(r,e,o,c,u,null,t,a,d,l,n,h):window.alert("inferenceSubVolumes() is not dead code?")})}function ao(r=!0){return y(this,null,function*(){yield Ue(),ue().set("DEBUG",!1),ue().set("WEBGL_FORCE_F16_TEXTURES",r),ue().set("WEBGL_DELETE_TEXTURE_THRESHOLD",-1),yield Xe()})}function ro(r,e,o,c,u,s){return y(this,null,function*(){const t=[];t.startTime=Date.now(),s("Segmentation started",0),performance.now();const a=r.batchSize,d=r.numOfChan;if(isNaN(a)||a!==1){const b="The batch Size for input shape must be 1";return s(b,-1,b),0}if(isNaN(d)||d!==1){const b="The number of channels for input shape must be 1";return s(b,-1,b),0}I().startScope();const l=yield Ne(r.rootURL+e.path);yield ao(!0),t.TF_Backend=He();const n=l;let h=[];if(h=n.layers[0].batchInputShape,h.length!==5){const b="The model input shape must be 5D";return s(b,-1,b),0}let m,p,i;const S=o.dims[1],M=o.dims[2],f=o.dims[3];if(yield te(n)){if(isNaN(h[4])||h[4]!==1){const b="The number of channels for input shape must be 1";return s(b,-1,b),0}m=h[1],p=h[2],i=h[3]}else{if(isNaN(h[1])||h[1]!==1){const b="The number of channels for input shape must be 1";return s(b,-1,b),0}m=h[2],p=h[3],i=h[4]}let w;m===256&&p===256&&i===256?w=!0:w=!1,t.isModelFullVol=w;let _=yield De(f,o,c);const L=e.enableTranspose,T=e.enableCrop;w&&(T?yield no(l,_,f,M,S,w,e,t,r,u,s,c):(L&&(_=_.transpose()),e.enableSeqConv?window.alert("inferenceFullVolumeSeqCovLayer() is not dead code?"):window.alert("inferenceFullVolume() is not dead code?")))})}function be(){return y(this,null,function*(){return navigator.userAgent.indexOf("OPR/")>-1?"Opera":navigator.userAgent.indexOf("Edg/")>-1?"Edge":navigator.userAgent.indexOf("Falkon/")>-1?"Falkon":navigator.userAgent.indexOf("Chrome/")>-1?"Chrome":navigator.userAgent.indexOf("Firefox/")>-1?"Firefox":navigator.userAgent.indexOf("Safari/")>-1?"Safari":navigator.userAgent.indexOf("MSIE/")>-1||navigator.userAgent.indexOf("rv:")>-1?"IExplorer":"Unknown"})}function so(){return y(this,null,function*(){return navigator.userAgent.indexOf("OPR/")>-1?parseInt(navigator.userAgent.split("OPR/")[1]):navigator.userAgent.indexOf("Edg/")>-1?parseInt(navigator.userAgent.split("Edg/")[1]):navigator.userAgent.indexOf("Falkon/")>-1?parseInt(navigator.userAgent.split("Falkon/")[1]):navigator.userAgent.indexOf("Chrome/")>-1?parseInt(navigator.userAgent.split("Chrome/")[1]):navigator.userAgent.indexOf("Firefox/")>-1?parseInt(navigator.userAgent.split("Firefox/")[1]):navigator.userAgent.indexOf("Safari/")>-1?parseInt(navigator.userAgent.split("Safari/")[1]):navigator.userAgent.indexOf("MSIE/")>-1||navigator.userAgent.indexOf("rv:")>-1?parseInt(navigator.userAgent.split("MSIE/")[1]):1/0})}function to(){return y(this,null,function*(){return navigator.userAgent.indexOf("Win")>-1?"Windows":navigator.userAgent.indexOf("Mac")>-1?"MacOS":navigator.userAgent.indexOf("Linux")>-1?"Linux":navigator.userAgent.indexOf("UNIX")>-1?"UNIX":"Unknown"})}function lo(r){return y(this,null,function*(){return!!r})}function io(r){return y(this,null,function*(){let e;if(r&&(e=r.getExtension("WEBGL_debug_renderer_info"),e)){const o=r.getParameter(e.UNMASKED_VENDOR_WEBGL);return o.indexOf("(")>-1&&o.indexOf(")")>-1?o.substring(o.indexOf("(")+1,o.indexOf(")")):o}return null})}function co(r){return y(this,null,function*(){if(r){const e=r.getExtension("WEBGL_debug_renderer_info");return e?r.getParameter(e.UNMASKED_VENDOR_WEBGL):null}else return null})}function uo(r){return y(this,null,function*(){if(r){if(be()==="Firefox")return r.getParameter(r.RENDERER);const e=r.getExtension("WEBGL_debug_renderer_info");return e?r.getParameter(e.UNMASKED_RENDERER_WEBGL):null}else return null})}function po(r){return y(this,null,function*(){let e;if(r){if(be()==="Firefox")return r.getParameter(r.RENDERER);if(e=r.getExtension("WEBGL_debug_renderer_info"),e){let o=r.getParameter(e.UNMASKED_RENDERER_WEBGL);return o.indexOf("(")>-1&&o.indexOf(")")>-1&&o.indexOf("(R)")===-1&&(o=o.substring(o.indexOf("(")+1,o.indexOf(")")),o.split(",").length===3)?o.split(",")[1].trim():o}}return null})}function fo(){return y(this,null,function*(){return navigator.hardwareConcurrency})}function Fe(){return y(this,null,function*(){return/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)})}function ho(r,e=null){return y(this,null,function*(){const o=new Date;if(r.isModelFullVol?r.Brainchop_Ver="FullVolume":r.Brainchop_Ver="SubVolumes",r.Total_t=(Date.now()-r.startTime)/1e3,delete r.startTime,r.Date=parseInt(o.getMonth()+1)+"/"+o.getDate()+"/"+o.getFullYear(),r.Browser=yield be(),r.Browser_Ver=yield so(),r.OS=yield to(),r.WebGL2=yield lo(e),r.GPU_Vendor=yield io(e),r.GPU_Card=yield po(e),r.GPU_Vendor_Full=yield co(e),r.GPU_Card_Full=yield uo(e),r.CPU_Cores=yield fo(),r.Which_Brainchop="latest",(yield Fe())&&(r.Heap_Size_MB=window.performance.memory.totalJSHeapSize/(1024*1024).toFixed(2),r.Used_Heap_MB=window.performance.memory.usedJSHeapSize/(1024*1024).toFixed(2),r.Heap_Limit_MB=window.performance.memory.jsHeapSizeLimit/(1024*1024).toFixed(2)),e){const c=e.getExtension("WEBGL_debug_renderer_info");r.Texture_Size=e.getParameter(e.MAX_TEXTURE_SIZE)}else r.Texture_Size=null;return r})}function mo(r){return new Worker("/assets/brainchop-webworker-4jrigAuM.js",{name:r==null?void 0:r.name})}function go(){return y(this,null,function*(){dragMode.onchange=function(){return y(this,null,function*(){i.opts.dragMode=this.selectedIndex})},drawDrop.onchange=function(){return y(this,null,function*(){if(i.volumes.length<2){window.alert("No segmentation open (use the Segmentation pull down)"),drawDrop.selectedIndex=-1;return}if(!i.drawBitmap){window.alert("No drawing (hint: use the Draw pull down to select a pen)"),drawDrop.selectedIndex=-1;return}const f=parseInt(this.value);if(f===0){i.drawUndo(),drawDrop.selectedIndex=-1;return}let g=i.volumes[1].img,w=yield i.saveImage({filename:"",isSaveDrawing:!0});const _=352,L=w.length;if(f===1)for(let T=0;T<L;T++)w[_+T]>0&&(g[T]=1);if(f===2)for(let T=0;T<L;T++)w[_+T]>0&&(g[T]=0);i.closeDrawing(),i.updateGLVolume(),i.setDrawingEnabled(!1),penDrop.selectedIndex=-1,drawDrop.selectedIndex=-1})},penDrop.onchange=function(){return y(this,null,function*(){const f=parseInt(this.value);i.setDrawingEnabled(f>=0),f>=0&&i.setPenValue(f&7,f>7)})},aboutBtn.onclick=function(){window.alert("Drag and drop NIfTI images. Use pulldown menu to choose brainchop model")},diagnosticsBtn.onclick=function(){if(h.length<1){window.alert("No diagnostic string generated: run a model to create diagnostics");return}m=m.slice(0,-2),m!==""&&h.includes("Status: OK")&&(h=h.replace("Status: OK",`Status: ${m}`)),m="",navigator.clipboard.writeText(h),window.alert(`Diagnostics copied to clipboard
`+h)},opacitySlider0.oninput=function(){i.setOpacity(0,opacitySlider0.value/255),i.updateGLVolume()},opacitySlider1.oninput=function(){i.setOpacity(1,opacitySlider1.value/255)};function r(){return y(this,null,function*(){const f=i.volumes[0];let g=f.dims[1]===256&&f.dims[2]===256&&f.dims[3]===256&&f.img instanceof Uint8Array&&f.img.length===256*256*256;if((f.permRAS[0]!==-1||f.permRAS[1]!==3||f.permRAS[2]!==-2)&&(g=!1),g)return;const w=yield i.conform(f,!1);yield i.removeVolume(i.volumes[0]),yield i.addVolume(w)})}function e(){return y(this,null,function*(){for(;i.volumes.length>1;)yield i.removeVolume(i.volumes[1])})}modelSelect.onchange=function(){return y(this,null,function*(){this.selectedIndex<0&&(modelSelect.selectedIndex=11),yield e(),yield r();const f=ee[this.selectedIndex],g=$e,w=new URL(window.location.href);if(g.rootURL=w.origin+w.pathname,!!(window.location.hostname==="localhost"||window.location.hostname==="[::1]"||window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/))&&(g.rootURL=location.protocol+"//"+location.host),workerCheck.checked){if(typeof p!="undefined")return;p=yield new mo({});const L={datatypeCode:i.volumes[0].hdr.datatypeCode,dims:i.volumes[0].hdr.dims},T={opts:g,modelEntry:f,niftiHeader:L,niftiImage:i.volumes[0].img};p.postMessage(T),p.onmessage=function(b){const P=b.data.cmd;P==="ui"&&(b.data.modalMessage!==""&&(p.terminate(),p=void 0),d(b.data.message,b.data.progressFrac,b.data.modalMessage,b.data.statData)),P==="img"&&(p.terminate(),p=void 0,t(b.data.img,b.data.opts,b.data.modelEntry))}}else ro(g,f,i.volumes[0].hdr,i.volumes[0].img,t,d)})},saveImgBtn.onclick=function(){i.volumes[1].saveToDisk("segmentaion.nii.gz")},saveSceneBtn.onclick=function(){i.saveDocument("brainchop.nvd")},workerCheck.onchange=function(){modelSelect.onchange()},clipCheck.onchange=function(){clipCheck.checked?i.setClipPlane([0,0,90]):i.setClipPlane([2,0,90])};function o(){opacitySlider0.oninput()}function c(f){return y(this,null,function*(){return yield(yield fetch(f)).json()})}function u(f){return y(this,null,function*(){const g=new Map;for(let _=0;_<f.length;_++){const L=f[_];g.has(L)?g.set(L,g.get(L)+1):g.set(L,1)}return Array.from(g,([_,L])=>({value:_,count:L}))})}function s(f,g){return y(this,null,function*(){return f.length!==g.length&&(m="Failed to Predict Labels - "),g.map((w,_)=>{const L=f.find(b=>b.value===_),T=L?`${L.count} mm3`:"Missing";return T==="Missing"&&(m+=`${w}, `),`${w}   ${T}`})})}function t(f,g,w){return y(this,null,function*(){e();const _=yield i.volumes[0].clone();_.zeroImage(),_.hdr.scl_inter=0,_.hdr.scl_slope=1,_.img=new Uint8Array(f);const L=yield u(_.img);if(w.colormapPath){const T=yield c(w.colormapPath),b=yield s(L,T.labels);_.setColormapLabel({R:T.R,G:T.G,B:T.B,labels:b}),_.hdr.intent_code=1002}else{let T=g.atlasSelectedColorTable.toLowerCase();i.colormaps().includes(T)||(T="actc"),_.colormap=T}_.opacity=opacitySlider1.value/255,yield i.addVolume(_)})}function a(f){return y(this,null,function*(){(typeof f=="string"||f instanceof String)&&(f=function(w){const _=JSON.parse(w),L=[];for(const T in _)L[T]=_[T];return L}(f)),f=yield ho(f,i.gl),h=`:: Diagnostics can help resolve issues https://github.com/neuroneural/brainchop/issues ::
`;for(const g in f)h+=g+": "+f[g]+`
`})}function d(f="",g=-1,w="",_=[]){f!==""&&(document.getElementById("location").innerHTML=f),isNaN(g)?(memstatus.style.color="red",memstatus.innerHTML="Memory Issue"):g>=0&&(modelProgress.value=g*modelProgress.max),w!==""&&window.alert(w),Object.keys(_).length>0&&a(_)}function l(f){document.getElementById("location").innerHTML=f.string.split("   ").map(g=>`<p style="font-size: 14px;margin:0px;">${g}</p>`).join("")}const n={backColor:[.4,.4,.4,1],show3Dcrosshair:!0,onLocationChange:l};let h="",m="",p;const i=new We(n);i.attachToCanvas(gl1),i.opts.dragMode=i.dragModes.pan,i.opts.multiplanarForceRender=!0,i.opts.yoke3Dto2DZoom=!0,i.opts.crosshairGap=11,i.setInterpolation(!0),yield i.loadVolumes([{url:"./t1_crop.nii.gz"}]);for(let f=0;f<ee.length;f++){const g=document.createElement("option");g.text=ee[f].modelName,g.value=ee[f].id.toString(),modelSelect.appendChild(g)}i.onImageLoaded=o,modelSelect.selectedIndex=-1,drawDrop.selectedIndex=-1,workerCheck.checked=yield Fe();const M=new URLSearchParams(window.location.search).get("model");M&&(modelSelect.selectedIndex=Number(M),modelSelect.onchange())})}function yo(){return y(this,null,function*(){try{const e=yield(yield fetch("https://api.github.com/repos/neuroneural/brainchop")).json();document.getElementById("star-count").textContent=e.stargazers_count}catch(r){}})}(function(){return y(this,null,function*(){yield go(),yo()})})();
